
#Область СлужебныйПрограммныйИнтерфейс

#Область СинхронизацияСправочникаВидовПроверок

// см. КонтрольВеденияУчета.ПолучитьВидыПроверок.
Функция ПолучитьВидыПроверок(ВидПроверок, ПоискПоТочномуСоответствию = Истина) Экспорт
	
	ВидПроверкиМассив      = Новый Массив;
	ПараметрыСинхронизации = Новый Структура;
	
	Если ТипЗнч(ВидПроверок) = Тип("СправочникСсылка.ВидыПроверок") Тогда
		
		ВидПроверкиМассив.Добавить(ВидПроверок);
	
	ИначеЕсли ТипЗнч(ВидПроверок) = Тип("Строка") Тогда
		
		ПараметрыСинхронизации.Вставить("Свойство1", ВидПроверок);
		ВидПроверкиМассив = ОбычныйПоискВидаПроверки(ПараметрыСинхронизации, ПоискПоТочномуСоответствию);
		
	ИначеЕсли ТипЗнч(ВидПроверок) = Тип("Массив") Тогда
		
		ПараметрыСинхронизации = Новый Структура;
		КоличествоЭлементов    = ВидПроверок.Количество();
		Для Индекс = 0 По КоличествоЭлементов - 1 Цикл
			ПараметрыСинхронизации.Вставить("Свойство" + Формат(Индекс + 1, "ЧГ=0"), ВидПроверок.Получить(Индекс));
		КонецЦикла;
		
		Если ПараметрыСинхронизации.Количество() > КоличествоСвойств() Тогда
			ВидПроверкиМассив = РасширенныйПоискВидаПроверки(ПараметрыСинхронизации, ВидПроверок.Количество());
		Иначе
			ВидПроверкиМассив = ОбычныйПоискВидаПроверки(ПараметрыСинхронизации, ПоискПоТочномуСоответствию);
		КонецЕсли;
		
	КонецЕсли;
	
	Возврат ВидПроверкиМассив;
	
КонецФункции

#КонецОбласти

#Область СинхронизацияСправочникаПроверок

// См. ОбновлениеИнформационнойБазыБСП.ПриДобавленииОбработчиковОбновления.
Процедура ПриДобавленииОбработчиковОбновления(Обработчики) Экспорт
	
	// Обработчики обновления неразделенных данных.
	Обработчик = Обработчики.Добавить();
	Обработчик.ОбщиеДанные             = Истина;
	Обработчик.УправлениеОбработчиками = Истина;
	Обработчик.Приоритет               = 1;
	Обработчик.Версия                  = "*";
	Обработчик.РежимВыполнения         = "Оперативно";
	Обработчик.Процедура               = "КонтрольВеденияУчетаСлужебный.ЗаполнитьОбработчикиРазделенныхДанных";
	
	// Обработчики обновления разделенных данных.
	Обработчик = Обработчики.Добавить();
	Обработчик.Версия          = "*";
	Обработчик.РежимВыполнения = "Оперативно";
	Обработчик.Процедура       = "КонтрольВеденияУчетаСлужебный.ОбновитьВспомогательныеДанныеПоИзменениямКонфигурации";
	
КонецПроцедуры

// Заполняет обработчик разделенных данных, зависимый от изменения неразделенных данных.
//
// Параметры:
//   Обработчики - ТаблицаЗначений, Неопределено - см. описание
//    функции НоваяТаблицаОбработчиковОбновления общего модуля
//    ОбновлениеИнформационнойБазы.
//    В случае прямого вызова (не через механизм обновления
//    версии ИБ) передается Неопределено.
// 
Процедура ЗаполнитьОбработчикиРазделенныхДанных(Параметры = Неопределено) Экспорт
	
	Если Параметры <> Неопределено И ЕстьИзмененияПараметровСистемныхПроверок() Тогда
		Обработчики = Параметры.РазделенныеОбработчики;
		Обработчик = Обработчики.Добавить();
		Обработчик.Версия          = "*";
		Обработчик.РежимВыполнения = "Оперативно";
		Обработчик.Процедура       = "КонтрольВеденияУчетаСлужебный.ОбновитьВспомогательныеДанныеПоИзменениямКонфигурации";
	КонецЕсли;
	
КонецПроцедуры

// Обновляет вспомогательные данные, которые зависят от конфигурации частично.
//
// Обновляется при наличии изменений конфигурации, записанных в параметры
// ограничения доступа при обновлении базы данных на текущую версию конфигурации.
//
Процедура ОбновитьВспомогательныеДанныеПоИзменениямКонфигурации(Параметры = Неопределено) Экспорт
	
	Блокировка = Новый БлокировкаДанных;
	ЭлементБлокировки = Блокировка.Добавить("Справочник.ПравилаПроверкиУчета");
	
	НачатьТранзакцию();
	Попытка
		Блокировка.Заблокировать();
		ОбновитьВспомогательныеДанныеСправочникаПоИзменениямКонфигурации();
		ЗафиксироватьТранзакцию();
	Исключение
		ОтменитьТранзакцию();
		ВызватьИсключение;
	КонецПопытки;
	
КонецПроцедуры

// Процедура обновляета данные справочника правил проверки.
//
Процедура ОбновитьВспомогательныеДанныеСправочникаПоИзменениямКонфигурации() Экспорт
	
	УстановитьПривилегированныйРежим(Истина);
	
	ПоследниеИзменения = СтандартныеПодсистемыСервер.ИзмененияПараметраРаботыПрограммы(
		"СтандартныеПодсистемы.КонтрольВеденияУчета.СистемныеПроверки");
	
	Если ПоследниеИзменения <> Неопределено И ПоследниеИзменения.Количество() > 0 Тогда
		ЗаполнитьПравилаПроверкиУчета();
	КонецЕсли;
	
КонецПроцедуры

// Процедура Обновляет состав предопределенных профилей в
// параметрах ограничения доступа при изменении конфигурации.
// 
// Параметры:
//  ЕстьИзменения - Булево (возвращаемое значение) - если производилась запись,
//                  устанавливается Истина, иначе не изменяется.
//
Процедура ОбновитьПараметрыСистемныхПроверок(ЕстьИзменения = Неопределено) Экспорт
	
	УстановитьПривилегированныйРежим(Истина);
	
	ХэшированиеСистемныхПроверок = ХэшированиеСистемныхПроверок();
	
	НачатьТранзакцию();
	Попытка
		ЕстьТекущиеИзменения = Ложь;
		
		СтандартныеПодсистемыСервер.ОбновитьПараметрРаботыПрограммы(
			"СтандартныеПодсистемы.КонтрольВеденияУчета.СистемныеПроверки",
			ХэшированиеСистемныхПроверок, ЕстьТекущиеИзменения);
		
		СтандартныеПодсистемыСервер.ДобавитьИзмененияПараметраРаботыПрограммы(
			"СтандартныеПодсистемы.КонтрольВеденияУчета.СистемныеПроверки",
			?(ЕстьТекущиеИзменения, Новый ФиксированнаяСтруктура("ЕстьИзменения", Истина), Новый ФиксированнаяСтруктура()));
		
		ЗафиксироватьТранзакцию();
	Исключение
		ОтменитьТранзакцию();
		ВызватьИсключение;
	КонецПопытки;
	
	Если ЕстьТекущиеИзменения Тогда
		ЕстьИзменения = Истина;
	КонецЕсли;
	
КонецПроцедуры

// Функция формирует хэш таблицы проверок, для сравнения с предыдущим хешем,
// хранящимся в информационной базе (РегистрСведений.ПараметрыРаботыПрограммы).
// Хэш формируется следующим образом: Формируются таблицы проверок (будущие элементы справочника
// ПравилаПроверкиУчета)  и групп проверок (будущие группы указанного справочника) на текущий 
// момент (момент обновления информационной базы). Далее формируется массив структур, на основании
// которого расчитывается фиксированное соответствие, от которого, в свою очередь, расчитывается хэш-сумма.
//
// Возвращаемое значение:
//     ФиксированноеСоответствие - Фиксированное соответствие, содержащее указанную хэш-сумму.
//
Функция ХэшированиеСистемныхПроверок()
	
	ДанныеСистемныхПроверок = Новый Соответствие;
	
	ПроверкиВеденияУчета = КонтрольВеденияУчетаПовтИсп.ПроверкиВеденияУчета();
	МассивХэша           = Новый Массив;
	
	Для Каждого ЭлементПроверокУчета Из ПроверкиВеденияУчета Цикл
		
		ЗначениеЭлементаПроверок = ЭлементПроверокУчета.Значение;
		КолонкиЭлементаПроверок  = ЗначениеЭлементаПроверок.Колонки;
		
		Для Каждого СтрокаЭлементаПроверок Из ЗначениеЭлементаПроверок Цикл
			
			СтруктураСтроки = Новый Структура;
			
			Для Каждого КолонкаЭлементаПроверок Из КолонкиЭлементаПроверок Цикл
				СтруктураСтроки.Вставить(КолонкаЭлементаПроверок.Имя, СтрокаЭлементаПроверок[КолонкаЭлементаПроверок.Имя]);
			КонецЦикла;
			
			Если СтруктураСтроки.Количество() > 0 Тогда
				МассивХэша.Добавить(СтруктураСтроки);
			КонецЕсли;
			
		КонецЦикла;
		
	КонецЦикла;
	
	ДанныеСистемныхПроверок.Вставить(ОбщегоНазначения.КонтрольнаяСуммаСтрокой(Новый ФиксированныйМассив(МассивХэша)));
	
	Возврат Новый ФиксированноеСоответствие(ДанныеСистемныхПроверок);
	
КонецФункции

// Проверяет были ли изменения неразделенных данных для какой-нибудь области данных.
//
Функция ЕстьИзмененияПараметровСистемныхПроверок()
	
	УстановитьПривилегированныйРежим(Истина);
	
	Параметры = Новый Массив;
	Параметры.Добавить("СтандартныеПодсистемы.КонтрольВеденияУчета.СистемныеПроверки");
	
	Для Каждого Параметр Из Параметры Цикл
		
		ПоследниеИзменения = СтандартныеПодсистемыСервер.ИзмененияПараметраРаботыПрограммы(Параметр);
		
		Если ПоследниеИзменения = Неопределено Или ПоследниеИзменения.Количество() > 0 Тогда
			Возврат Истина;
		КонецЕсли;
		
	КонецЦикла;
	
	Возврат Ложь;
	
КонецФункции

// Обновляет справочник проверок. Синхронизация производиться по специальному идентификатору.
//
Процедура ЗаполнитьПравилаПроверкиУчета() Экспорт
	
	ПроверкиВеденияУчета = КонтрольВеденияУчетаПовтИсп.ПроверкиВеденияУчета();
	
	ОбновлениеСправочникаПроверок(ПроверкиВеденияУчета.ГруппыПроверок, ПроверкиВеденияУчета.Проверки);
	
КонецПроцедуры

#КонецОбласти

#Область ОписанияАлгоритмовПоставляемыхПроверок

// Исполняет проверку ссылочной целостности.
//
// Параметры:
//   Проверка            - СправочникСсылка.ПравилаПроверкиУчета - Ссылка на исполняемую проверку.
//   ПараметрыПроверки   - Структура - Параметры проверки которую необходимо выполнить:
//       * Идентификатор                     - Строка - Строковый идентификатор проверки.
//       * Представление                     - Строка - Пользовательское представление проверки.
//       * ИдентификаторРегламентногоЗадания - Строка - Строковый идентификатор регламентного задания,
//                                             соответствующего проверке.
//       * ДатаНачалаПроверки                - Дата - Пороговая дата, обозначающая границу проверяемых
//                                             объектов (только для объектов с датой). Объекты, дата которых
//                                             меньше указанной, не следует проверять. По умолчанию не 
//                                             заполнено (т.е. проверять все).
//       * ЛимитПроблем                      - Число - Количество проверяемых объектов.
//                                             По умолчанию 1000. Если указано 0, то следует проверить все объекты.
//       * Проверка                          - СправочникСсылка.ПравилаПроверкиУчета - Ссылка на
//                                             выполненную проверку.
//       * ВидПроверки                       - СправочникСсылка.ВидыПроверок - Ссылка на вид проверки, к
//                                             которому относится выполненная проверка.
//       * ВажностьПроблемы                  - ПеречислениеСсылка.ВажностьПроблемыУчета - Важность проблемы учета
//                                             "Информация", "Предупреждение", "Ошибка" и "ПолезныйСовет".
//
Процедура ПроверитьСсылочнуюЦелостность(Проверка, ПараметрыПроверки) Экспорт
	
	Если ОбщегоНазначения.РазделениеВключено() Тогда
		Возврат;
	КонецЕсли;
	
	СсылочныеВидыОбъектовМетаданных = КонтрольВеденияУчетаПовтИсп.СсылочныеВидыОбъектовМетаданных();
	РегистрыКакОбъектыМетаданных    = КонтрольВеденияУчетаПовтИсп.РегистрыКакОбъектыМетаданных();
	
	Для Каждого СсылочныйВидОбъектаМетаданных Из СсылочныеВидыОбъектовМетаданных Цикл
		ВидМетаданных = СсылочныйВидОбъектаМетаданных.ВидОбъектаМетаданных;
		Для Каждого ОбъектМетаданных Из ВидМетаданных Цикл
			НайтиБитыеСсылки(ОбъектМетаданных, ПараметрыПроверки);
		КонецЦикла;
	КонецЦикла;
	
	Для Каждого РегистрКакОбъектМетаданных Из РегистрыКакОбъектыМетаданных Цикл
		ВидМетаданных = РегистрКакОбъектМетаданных.ВидОбъектаМетаданных;
		Для Каждого ОбъектМетаданных Из ВидМетаданных Цикл
			НайтиБитыеСсылкиВРегистрах(ОбъектМетаданных, ПараметрыПроверки);
		КонецЦикла;
	КонецЦикла;
	
КонецПроцедуры

// Исполняет проверку заполненности обязательных реквизитов.
//
// Параметры:
//   Проверка            - СправочникСсылка.ПравилаПроверкиУчета - Ссылка на исполняемую проверку.
//   ПараметрыПроверки   - Структура - Параметры проверки которую необходимо выполнить:
//       * Идентификатор                     - Строка - Строковый идентификатор проверки.
//       * Представление                     - Строка - Пользовательское представление проверки.
//       * ИдентификаторРегламентногоЗадания - Строка - Строковый идентификатор регламентного задания,
//                                             соответствующего проверке.
//       * ДатаНачалаПроверки                - Дата - Пороговая дата, обозначающая границу проверяемых
//                                             объектов (только для объектов с датой). Объекты, дата которых
//                                             меньше указанной, не следует проверять. По умолчанию не 
//                                             заполнено (т.е. проверять все).
//       * ЛимитПроблем                      - Число - Количество проверяемых объектов.
//                                             По умолчанию 1000. Если указано 0, то следует проверить все объекты.
//       * Проверка                          - СправочникСсылка.ПравилаПроверкиУчета - Ссылка на
//                                             выполненную проверку.
//       * ВидПроверки                       - СправочникСсылка.ВидыПроверок - Ссылка на вид проверки, к
//                                             которому относится выполненная проверка.
//       * ВажностьПроблемы                  - ПеречислениеСсылка.ВажностьПроблемыУчета - Важность проблемы учета
//                                             "Информация", "Предупреждение", "Ошибка" и "ПолезныйСовет".
//
Процедура ПроверитьНезаполненныеОбязательныеРеквизиты(Проверка, ПараметрыПроверки) Экспорт
	
	СсылочныеВидыОбъектовМетаданных = КонтрольВеденияУчетаПовтИсп.СсылочныеВидыОбъектовМетаданных();
	РегистрыКакОбъектыМетаданных    = КонтрольВеденияУчетаПовтИсп.РегистрыКакОбъектыМетаданных();
	
	Для Каждого СсылочныйВидОбъектаМетаданных Из СсылочныеВидыОбъектовМетаданных Цикл
		
		ВидМетаданных = СсылочныйВидОбъектаМетаданных.ВидОбъектаМетаданных;
		Для Каждого ОбъектМетаданных Из ВидМетаданных Цикл
			Если ЭтоНеразделенныйОбъектМетаданных(ОбъектМетаданных.ПолноеИмя()) Тогда
				Продолжить;
			КонецЕсли;
			Если Не ОбщегоНазначения.ОбъектМетаданныхДоступенПоФункциональнымОпциям(ОбъектМетаданных) Тогда
				Продолжить;
			КонецЕсли;
			НайтиНезаполненныеОбязательныеРеквизиты(ОбъектМетаданных, ПараметрыПроверки);
		КонецЦикла;
		
	КонецЦикла;
	
	Для Каждого РегистрКакОбъектМетаданных Из РегистрыКакОбъектыМетаданных Цикл
		ВидМетаданных = РегистрКакОбъектМетаданных.ВидОбъектаМетаданных;
		Для Каждого ОбъектМетаданных Из ВидМетаданных Цикл
			Если ЭтоНеразделенныйОбъектМетаданных(ОбъектМетаданных.ПолноеИмя()) Тогда
				Продолжить;
			КонецЕсли;
			Если Не ОбщегоНазначения.ОбъектМетаданныхДоступенПоФункциональнымОпциям(ОбъектМетаданных) Тогда
				Продолжить;
			КонецЕсли;
			НайтиНезаполненныеОбязательныеРеквизитыВРегистрах(ОбъектМетаданных, ПараметрыПроверки);
		КонецЦикла;
	КонецЦикла;
	
КонецПроцедуры

// Исполняет проверку наличия циклических ссылок.
//
// Параметры:
//   Проверка            - СправочникСсылка.ПравилаПроверкиУчета - Ссылка на исполняемую проверку.
//   ПараметрыПроверки   - Структура - Параметры проверки которую необходимо выполнить:
//       * Идентификатор                     - Строка - Строковый идентификатор проверки.
//       * Представление                     - Строка - Пользовательское представление проверки.
//       * ИдентификаторРегламентногоЗадания - Строка - Строковый идентификатор регламентного задания,
//                                             соответствующего проверке.
//       * ДатаНачалаПроверки                - Дата - Пороговая дата, обозначающая границу проверяемых
//                                             объектов (только для объектов с датой). Объекты, дата которых
//                                             меньше указанной, не следует проверять. По умолчанию не 
//                                             заполнено (т.е. проверять все).
//       * ЛимитПроблем                      - Число - Количество проверяемых объектов.
//                                             По умолчанию 1000. Если указано 0, то следует проверить все объекты.
//       * Проверка                          - СправочникСсылка.ПравилаПроверкиУчета - Ссылка на
//                                             выполненную проверку.
//       * ВидПроверки                       - СправочникСсылка.ВидыПроверок - Ссылка на вид проверки, к
//                                             которому относится выполненная проверка.
//       * ВажностьПроблемы                  - ПеречислениеСсылка.ВажностьПроблемыУчета - Важность проблемы учета
//                                             "Информация", "Предупреждение", "Ошибка" и "ПолезныйСовет".
//
Процедура ПроверитьЦиклическиеСсылки(Проверка, ПараметрыПроверки) Экспорт
	
	СсылочныеВидыОбъектовМетаданных = КонтрольВеденияУчетаПовтИсп.СсылочныеВидыОбъектовМетаданных();
	
	Для Каждого СсылочныйВидОбъектаМетаданных Из СсылочныеВидыОбъектовМетаданных Цикл
		ВидМетаданных = СсылочныйВидОбъектаМетаданных.ВидОбъектаМетаданных;
		Для Каждого ОбъектМетаданных Из ВидМетаданных Цикл
			Если ЭтоНеразделенныйОбъектМетаданных(ОбъектМетаданных.ПолноеИмя()) Тогда
				Продолжить;
			КонецЕсли;
			Если Не ЕстьИерархия(ОбъектМетаданных.СтандартныеРеквизиты) Тогда
				Продолжить;
			КонецЕсли;
			НайтиЦиклическиеСсылки(ОбъектМетаданных, ПараметрыПроверки);
		КонецЦикла;
	КонецЦикла;
	
КонецПроцедуры

// Исполняет проверку наличия отсутствующих предопределенных элементов.
//
// Параметры:
//   Проверка            - СправочникСсылка.ПравилаПроверкиУчета - Ссылка на исполняемую проверку.
//   ПараметрыПроверки   - Структура - Параметры проверки которую необходимо выполнить:
//       * Идентификатор                     - Строка - Строковый идентификатор проверки.
//       * Представление                     - Строка - Пользовательское представление проверки.
//       * ИдентификаторРегламентногоЗадания - Строка - Строковый идентификатор регламентного задания,
//                                             соответствующего проверке.
//       * ДатаНачалаПроверки                - Дата - Пороговая дата, обозначающая границу проверяемых
//                                             объектов (только для объектов с датой). Объекты, дата которых
//                                             меньше указанной, не следует проверять. По умолчанию не 
//                                             заполнено (т.е. проверять все).
//       * ЛимитПроблем                      - Число - Количество проверяемых объектов.
//                                             По умолчанию 1000. Если указано 0, то следует проверить все объекты.
//       * Проверка                          - СправочникСсылка.ПравилаПроверкиУчета - Ссылка на
//                                             выполненную проверку.
//       * ВидПроверки                       - СправочникСсылка.ВидыПроверок - Ссылка на вид проверки, к
//                                             которому относится выполненная проверка.
//       * ВажностьПроблемы                  - ПеречислениеСсылка.ВажностьПроблемыУчета - Важность проблемы учета
//                                             "Информация", "Предупреждение", "Ошибка" и "ПолезныйСовет".
//
Процедура ПроверитьОтсутствующиеПредопределенныеЭлементы(Проверка, ПараметрыПроверки) Экспорт
	
	Если ОбщегоНазначения.РазделениеВключено() Тогда
		Возврат;
	КонецЕсли;
	
	МассивВидовОбъектов = Новый Массив;
	МассивВидовОбъектов.Добавить("Справочник");
	МассивВидовОбъектов.Добавить("ПланВидовХарактеристик");
	МассивВидовОбъектов.Добавить("ПланСчетов");
	МассивВидовОбъектов.Добавить("ПланВидовРасчета");
	
	МассивВидовОбъектовМетаданных = Новый Массив;
	МассивВидовОбъектовМетаданных.Добавить(Метаданные.Справочники);
	МассивВидовОбъектовМетаданных.Добавить(Метаданные.ПланыВидовХарактеристик);
	МассивВидовОбъектовМетаданных.Добавить(Метаданные.ПланыСчетов);
	МассивВидовОбъектовМетаданных.Добавить(Метаданные.ПланыВидовРасчета);
	
	Для Каждого ВидМетаданных Из МассивВидовОбъектовМетаданных Цикл
		Для Каждого ОбъектМетаданных Из ВидМетаданных Цикл
			Если ОбъектМетаданных.ОбновлениеПредопределенныхДанных = Метаданные.СвойстваОбъектов.ОбновлениеПредопределенныхДанных.НеОбновлятьАвтоматически Тогда
				Продолжить;
			КонецЕсли;
			НайтиОтсутствующиеПредопределенныеЭлементы(ОбъектМетаданных, ПараметрыПроверки);
		КонецЦикла;
	КонецЦикла;
	
КонецПроцедуры

// Исполняет проверку наличия дублирующихся предопределенных элементов.
//
// Параметры:
//   Проверка            - СправочникСсылка.ПравилаПроверкиУчета - Ссылка на исполняемую проверку.
//   ПараметрыПроверки   - Структура - Параметры проверки которую необходимо выполнить:
//       * Идентификатор                     - Строка - Строковый идентификатор проверки.
//       * Представление                     - Строка - Пользовательское представление проверки.
//       * ИдентификаторРегламентногоЗадания - Строка - Строковый идентификатор регламентного задания,
//                                             соответствующего проверке.
//       * ДатаНачалаПроверки                - Дата - Пороговая дата, обозначающая границу проверяемых
//                                             объектов (только для объектов с датой). Объекты, дата которых
//                                             меньше указанной, не следует проверять. По умолчанию не 
//                                             заполнено (т.е. проверять все).
//       * ЛимитПроблем                      - Число - Количество проверяемых объектов.
//                                             По умолчанию 1000. Если указано 0, то следует проверить все объекты.
//       * Проверка                          - СправочникСсылка.ПравилаПроверкиУчета - Ссылка на
//                                             выполненную проверку.
//       * ВидПроверки                       - СправочникСсылка.ВидыПроверок - Ссылка на вид проверки, к
//                                             которому относится выполненная проверка.
//       * ВажностьПроблемы                  - ПеречислениеСсылка.ВажностьПроблемыУчета - Важность проблемы учета
//                                             "Информация", "Предупреждение", "Ошибка" и "ПолезныйСовет".
//
Процедура ПроверитьДублированиеПредопределенныхЭлементов(Проверка, ПараметрыПроверки) Экспорт
	
	Если ОбщегоНазначения.РазделениеВключено() Тогда
		Возврат;
	КонецЕсли;
	
	МассивВидовОбъектов = Новый Массив;
	МассивВидовОбъектов.Добавить("Справочник");
	МассивВидовОбъектов.Добавить("ПланВидовХарактеристик");
	МассивВидовОбъектов.Добавить("ПланСчетов");
	МассивВидовОбъектов.Добавить("ПланВидовРасчета");
	
	МассивВидовОбъектовМетаданных = Новый Массив;
	МассивВидовОбъектовМетаданных.Добавить(Метаданные.Справочники);
	МассивВидовОбъектовМетаданных.Добавить(Метаданные.ПланыВидовХарактеристик);
	МассивВидовОбъектовМетаданных.Добавить(Метаданные.ПланыСчетов);
	МассивВидовОбъектовМетаданных.Добавить(Метаданные.ПланыВидовРасчета);
	
	Для Каждого ВидМетаданных Из МассивВидовОбъектовМетаданных Цикл
		НайтиДублиПредопределенныхЭлементов(ВидМетаданных, ПараметрыПроверки);
	КонецЦикла;
	
КонецПроцедуры

// Исполняет проверку отсутствующих предопределенных узлов плана обмена.
//
// Параметры:
//   Проверка            - СправочникСсылка.ПравилаПроверкиУчета - Ссылка на исполняемую проверку.
//   ПараметрыПроверки   - Структура - Параметры проверки которую необходимо выполнить:
//       * Идентификатор                     - Строка - Строковый идентификатор проверки.
//       * Представление                     - Строка - Пользовательское представление проверки.
//       * ИдентификаторРегламентногоЗадания - Строка - Строковый идентификатор регламентного задания,
//                                             соответствующего проверке.
//       * ДатаНачалаПроверки                - Дата - Пороговая дата, обозначающая границу проверяемых
//                                             объектов (только для объектов с датой). Объекты, дата которых
//                                             меньше указанной, не следует проверять. По умолчанию не 
//                                             заполнено (т.е. проверять все).
//       * ЛимитПроблем                      - Число - Количество проверяемых объектов.
//                                             По умолчанию 1000. Если указано 0, то следует проверить все объекты.
//       * Проверка                          - СправочникСсылка.ПравилаПроверкиУчета - Ссылка на
//                                             выполненную проверку.
//       * ВидПроверки                       - СправочникСсылка.ВидыПроверок - Ссылка на вид проверки, к
//                                             которому относится выполненная проверка.
//       * ВажностьПроблемы                  - ПеречислениеСсылка.ВажностьПроблемыУчета - Важность проблемы учета
//                                             "Информация", "Предупреждение", "Ошибка" и "ПолезныйСовет".
//
Процедура ПроверитьНаличиеПредопределенныхУзловПлановОбмена(Проверка, ПараметрыПроверки) Экспорт
	
	Если ОбщегоНазначения.РазделениеВключено() Тогда
		Возврат;
	КонецЕсли;
	
	МассивВидовОбъектов = Новый Массив;
	МассивВидовОбъектов.Добавить("ПланОбмена");
	
	МетаданныеПланыОбмена = Метаданные.ПланыОбмена;
	Для Каждого МетаданныеПланОбмена Из МетаданныеПланыОбмена Цикл
		
		Если ПланыОбмена[МетаданныеПланОбмена.Имя].ЭтотУзел() <> Неопределено Тогда
			Продолжить;
		КонецЕсли;
		
		Проблема = ОписаниеПроблемы(ОбщегоНазначения.ИдентификаторОбъектаМетаданных(МетаданныеПланОбмена.ПолноеИмя()), ПараметрыПроверки);
		Проблема.УточнениеПроблемы = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(НСтр("ru = 'В плане обмена ""%1"" отсутствует предопределенный узел (ЭтотУзел() = Неопределено).'"), МетаданныеПланОбмена.Имя);
		ЗаписатьПроблему(Проблема, ПараметрыПроверки);
		
	КонецЦикла;
	
КонецПроцедуры

// Исполняет проверку корректности заполнения контактной информации.
//
// Параметры:
//   Проверка            - СправочникСсылка.ПравилаПроверкиУчета - Ссылка на исполняемую проверку.
//   ПараметрыПроверки   - Структура - Параметры проверки которую необходимо выполнить:
//       * Идентификатор                     - Строка - Строковый идентификатор проверки.
//       * Представление                     - Строка - Пользовательское представление проверки.
//       * ИдентификаторРегламентногоЗадания - Строка - Строковый идентификатор регламентного задания,
//                                             соответствующего проверке.
//       * ДатаНачалаПроверки                - Дата - Пороговая дата, обозначающая границу проверяемых
//                                             объектов (только для объектов с датой). Объекты, дата которых
//                                             меньше указанной, не следует проверять. По умолчанию не 
//                                             заполнено (т.е. проверять все).
//       * ЛимитПроблем                      - Число - Количество проверяемых объектов.
//                                             По умолчанию 1000. Если указано 0, то следует проверить все объекты.
//       * Проверка                          - СправочникСсылка.ПравилаПроверкиУчета - Ссылка на
//                                             выполненную проверку.
//       * ВидПроверки                       - СправочникСсылка.ВидыПроверок - Ссылка на вид проверки, к
//                                             которому относится выполненная проверка.
//       * ВажностьПроблемы                  - ПеречислениеСсылка.ВажностьПроблемыУчета - Важность проблемы учета
//                                             "Информация", "Предупреждение", "Ошибка" и "ПолезныйСовет".
//
Процедура ПроверитьКонтактнуюИнформацию(Проверка, ПараметрыПроверки) Экспорт
	
КонецПроцедуры

#КонецОбласти

#Область ОписаниеАлгоритмовИсправленияПроблем

Процедура ИсправитьПроблемуЦиклическихСсылокВФоновомЗадании(Знач ПараметрыПроверки, АдресХранилища = Неопределено) Экспорт
	
	Проверка = ПроверкаПоИдентификатору(ПараметрыПроверки.ИдентификаторПроверки);
	Если Не ЗначениеЗаполнено(Проверка) Тогда
		Возврат;
	КонецЕсли;
	
	ИсправитьПроблемуЦиклическихСсылок(Проверка);
	
КонецПроцедуры

#КонецОбласти

#Область НастройкаРегламентныхЗаданий

// См. КонтрольВеденияУчетаПереопределяемый.ПриПолученииСпискаШаблонов.
Процедура ПриПолученииСпискаШаблонов(ШаблоныЗаданий) Экспорт
	
	ШаблоныЗаданий.Добавить("ПроверкаВеденияУчета");
	
КонецПроцедуры

// Возвращает параметры проверки по переданному идентификатору регламентного задания.
//
//  Параметры
//    ИдентификаторРегламентногоЗадания - Строка - Поле для связки с текущим фоновым заданием.
//
//  Возвращаемое значение - Структура со свойствами::
//       * Идентификатор                     - Строка - Строковый идентификатор проверки.
//       * Наименование                      - Строка - Пользовательское представление проверки.
//       * ИдентификаторРегламентногоЗадания - Строка - Строковый идентификатор регламентного задания,
//                                             соответствующего проверке.
//       * ДатаНачалаПроверки                - Дата - Пороговая дата, обозначающая границу проверяемых
//                                             объектов (только для объектов с датой). Объекты, дата которых
//                                             меньше указанной, не следует проверять. По умолчанию не 
//                                             заполнено (т.е. проверять все).
//       * ЛимитПроблем                      - Число - Количество проверяемых объектов.
//                                             По умолчанию 1000. Если указано 0, то следует проверить все объекты..
//       * СпособВыполнения                  - ПеречислениеСсылка.СпособВыполненияПроверки - Способ выполнения проверки
//                                             "ПоОбщемуРасписанию", "ПоОтдельномуРасписанию" и "Вручную".
//
Функция ПараметрыПроверкиПоИдентификаторуРегламентногоЗадания(ИдентификаторРегламентногоЗадания) Экспорт
	
	Запрос = Новый Запрос(
	"ВЫБРАТЬ ПЕРВЫЕ 1
	|	ПравилаПроверкиУчета.Идентификатор КАК Идентификатор,
	|	ПравилаПроверкиУчета.Наименование КАК Наименование,
	|	ПравилаПроверкиУчета.ИдентификаторРегламентногоЗадания КАК ИдентификаторРегламентногоЗадания,
	|	ПравилаПроверкиУчета.ДатаНачалаПроверки КАК ДатаНачалаПроверки,
	|	ПравилаПроверкиУчета.ЛимитПроблем КАК ЛимитПроблем,
	|	ПравилаПроверкиУчета.СпособВыполнения КАК СпособВыполнения
	|ИЗ
	|	Справочник.ПравилаПроверкиУчета КАК ПравилаПроверкиУчета
	|ГДЕ
	|	ПравилаПроверкиУчета.ИдентификаторРегламентногоЗадания = &ИдентификаторРегламентногоЗадания
	|	И ПравилаПроверкиУчета.Использование");
	
	Запрос.УстановитьПараметр("ИдентификаторРегламентногоЗадания", Строка(ИдентификаторРегламентногоЗадания));
	Результат = Запрос.Выполнить().Выбрать();
	
	Если Не Результат.Следующий() Тогда
		Возврат Неопределено;
	Иначе
		
		СтруктураВозврата = Новый Структура;
		СтруктураВозврата.Вставить("Идентификатор",                     Результат.Идентификатор);
		СтруктураВозврата.Вставить("Наименование",                      Результат.Наименование);
		СтруктураВозврата.Вставить("ИдентификаторРегламентногоЗадания", Результат.ИдентификаторРегламентногоЗадания);
		СтруктураВозврата.Вставить("ДатаНачалаПроверки",                Результат.ДатаНачалаПроверки);
		СтруктураВозврата.Вставить("ЛимитПроблем",                      Результат.ЛимитПроблем);
		СтруктураВозврата.Вставить("СпособВыполнения",                  Результат.СпособВыполнения);
		СтруктураВозврата.Вставить("ПроверкаБылаОстановлена",           Ложь);
		СтруктураВозврата.Вставить("РучнойЗапуск",                      Ложь);
		
		Возврат СтруктураВозврата;
		
	КонецЕсли;
	
КонецФункции

#КонецОбласти

#Область ПользовательскаяИндикацияОшибок

// Размещает группу индикатора ошибок на управляемой форме.
//
// Параметры:
//  УправляемаяФорма     - УправляемаяФорма - Форма объекта на которой нужно разместить группу индикатора.
//  КлючУникальностиИмен - Строка - Строковый ключ уникальности добавляемых элементов на форму. Нужен для
//                         минимизации рисков пересечения с уже существующими элементами.
//  ИмяРодителяГруппы    - Строка, Неопределено - Строковое имя группы формы в контексте которой
//                         требуется разместить группу индикатора. Если неопределено, то в качестве
//                         контекста выступает управляемая форма. Если на форме не находится такого
//                         элемента генерируется исключение.
//  ВыводитьСнизу        - Булево - Определяет местоположение добавляемой группы,
//                         сигнализирующей об ошибке Если принимает значение "Истина",
//                         то группа будет добавлена в конец коллекции подчиненных
//                         элементов группы родителя. В противном случае группа будет
//                         расположена сразу за основной командной панелью формы объекта.
//
Функция РазместитьГруппуИндикатораОшибки(УправляемаяФорма, КлючУникальностиИмен, ИмяРодителяГруппы = Неопределено, ВыводитьСнизу = Ложь) Экспорт
	
	ВсеЭлементыФормы = УправляемаяФорма.Элементы;
	
	Если ИмяРодителяГруппы = Неопределено Тогда
		КонтекстРазмещения = УправляемаяФорма;
	Иначе
		РодительГруппы = ВсеЭлементыФормы.Найти(ИмяРодителяГруппы);
		Если РодительГруппы = Неопределено Тогда
			ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(НСтр("ru = 'Не найдена группа формы: ""%1""'"), ИмяРодителяГруппы);
		Иначе
			КонтекстРазмещения = РодительГруппы;
		КонецЕсли;
	КонецЕсли;
	
	ГруппаИндикатораОшибки = ВсеЭлементыФормы.Добавить("ГруппаИндикатораОшибки_" + КлючУникальностиИмен, Тип("ГруппаФормы"), КонтекстРазмещения);
	ГруппаИндикатораОшибки.Вид                      = ВидГруппыФормы.ОбычнаяГруппа;
	ГруппаИндикатораОшибки.ОтображатьЗаголовок      = Ложь;
	ГруппаИндикатораОшибки.Группировка              = ГруппировкаПодчиненныхЭлементовФормы.Горизонтальная;
	ГруппаИндикатораОшибки.РастягиватьПоГоризонтали = Истина;
	ГруппаИндикатораОшибки.ЦветФона                 = ЦветаСтиля.ФонУправляющегоПоля;
	
	ПодчиненныеЭлементыКонтекста = КонтекстРазмещения.ПодчиненныеЭлементы;
	Если ВыводитьСнизу Тогда
		ВсеЭлементыФормы.Переместить(ГруппаИндикатораОшибки, КонтекстРазмещения);
	Иначе
		Если ПодчиненныеЭлементыКонтекста.Количество() > 0 Тогда
			ВсеЭлементыФормы.Переместить(ГруппаИндикатораОшибки, КонтекстРазмещения, ПодчиненныеЭлементыКонтекста.Получить(0));
		КонецЕсли;
	КонецЕсли;
	
	Возврат ГруппаИндикатораОшибки;
	
КонецФункции

// Заполняет размещенную ранее группу индикатора ошибок элементами
//   идентифицирующими наличие ошибок и позволяющими перейти к отчету по этим ошибкам.
//
// Параметры
//  УправляемаяФорма             - УправляемаяФорма - Форма объекта на которой расположена группа индикатора.
//  ГруппаИндикатораОшибки       - ГруппаФормы - Группа управляемой формы на которой будут располагаться
//                                 элементы-декорации, которые будут идентифицировать наличие ошибок с возможностью
//                                 перехода к отчету.
//  КлючУникальностиИмен         - Строка - Строковый ключ уникальности добавляемых элементов на форму. Нужен для
//                                 минимизации рисков пересечения с уже существующими элементами.
//  КартинкаИндикатораПроблем    - Картинка, Неопределено - Картинка идентифицирующая наличие проблем у текущего объекта.
//                                 Может быть переопределена конечным разработчиком - достаточно добавить параметр при вызове.
//  ОбщаяСтрокаИндикатор         - ФорматированнаяСтрока - Общая строка-индикатор наличия ошибок. Состоит из
//                                 поясняющего текста и гиперссылки открывающей отчет по проблемам объекта..
//
Процедура ЗаполнитьГруппуИндикатораОшибки(УправляемаяФорма, ГруппаИндикатораОшибки, КлючУникальностиИмен,
	ОбщаяСтрокаИндикатор, КартинкаИндикатораПроблем = Неопределено) Экспорт
	
	ЭлементыУправляемойФормы = УправляемаяФорма.Элементы;
	
	КартинкаИндикаторОшибки = ЭлементыУправляемойФормы.Добавить("ДекорацияКартинка_" + КлючУникальностиИмен, Тип("ДекорацияФормы"), ГруппаИндикатораОшибки);
	КартинкаИндикаторОшибки.Вид            = ВидДекорацииФормы.Картинка;
	КартинкаИндикаторОшибки.Картинка       = ?(КартинкаИндикатораПроблем = Неопределено, БиблиотекаКартинок.Предупреждение, КартинкаИндикатораПроблем);
	КартинкаИндикаторОшибки.РазмерКартинки = РазмерКартинки.РеальныйРазмер;
	
	ДекорацияНадпись = ЭлементыУправляемойФормы.Добавить("ДекорацияНадпись_" + КлючУникальностиИмен, Тип("ДекорацияФормы"), ГруппаИндикатораОшибки);
	ДекорацияНадпись.Вид                   = ВидДекорацииФормы.Надпись;
	ДекорацияНадпись.Заголовок             = ОбщаяСтрокаИндикатор;
	ДекорацияНадпись.ВертикальноеПоложение = ВертикальноеПоложениеЭлемента.Центр;
	ДекорацияНадпись.УстановитьДействие("ОбработкаНавигационнойСсылки", "Подключаемый_ОткрытьОтчетПоПроблемам");
	
КонецПроцедуры

// Формирует общую строку-индикатор наличия ошибок. Состоит из поясняющего текста и
// гиперссылки открывающей отчет по проблемам объекта.
//
// Параметры
//  УправляемаяФорма             - УправляемаяФорма - Форма объекта на которой расположена группа индикатора.
//  СсылкаНаОбъект               - ЛюбаяСсылка - Ссылка на объект по которому найдены ошибки.
//  КоличествоПроблемПоОбъекту   - Число - Найденное количество проблем по объекту.
//  ПояснениеИндикатораПроблем   - Строка, Неопределено - Строка идентифицирующая  наличие проблем у текущего объекта.
//                                 Может быть переопределена конечным разработчиком - достаточно добавить параметр при вызове.
//  ГиперссылкаИндикатораПроблем - Строка, Неопределено - Строка представляющая гиперссылку, при нажатии 
//                                 на которую будет открыт и сформирован отчет по проблемам текущего объекта.
//
Функция СформироватьОбщуюСтрокуИндикатор(УправляемаяФорма, СсылкаНаОбъект, КоличествоПроблемПоОбъекту,
	ПояснениеИндикатораПроблем = Неопределено, ГиперссылкаИндикатораПроблем = Неопределено) Экспорт
	
	ТекстоваяСсылка = "Основной";
	
	Если ПояснениеИндикатораПроблем <> Неопределено Тогда
		ПоясняющаяНадпись = ПояснениеИндикатораПроблем
	Иначе
		ПоясняющаяНадпись = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(НСтр("ru = 'С этим %1'"), ПредставлениеОбъектаПоТипу(СсылкаНаОбъект));
	КонецЕсли;
	
	Если ГиперссылкаИндикатораПроблем <> Неопределено Тогда
		Гиперссылка = ГиперссылкаИндикатораПроблем;
	Иначе
		Гиперссылка = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(НСтр("ru='есть проблемы (%1)'"), Формат(КоличествоПроблемПоОбъекту, "ЧГ=0"));
	КонецЕсли;
	
	Возврат Новый ФорматированнаяСтрока(ПоясняющаяНадпись + " ", Новый ФорматированнаяСтрока(Гиперссылка, , , , ТекстоваяСсылка));
	
КонецФункции

// См. КонтрольВеденияУчетаПереопределяемый.ПриОпределенииПараметровГруппыИндикации.
Процедура ПриОпределенииПараметровГруппыИндикации(ПараметрыГруппыИндикации, ТипСсылки) Экспорт
	
	ПараметрыГруппыИндикации.Вставить("ИмяРодителяГруппы", Неопределено);
	ПараметрыГруппыИндикации.Вставить("ВыводитьСнизу",     Ложь);
	
КонецПроцедуры

// См. КонтрольВеденияУчетаПереопределяемый.ПриОпределенииПараметровКолонкиИндикации.
Процедура ПриОпределенииПараметровКолонкиИндикации(ПараметрыКолонкиИндикации, ПолноеИмя) Экспорт
	
	ПараметрыКолонкиИндикации.Вставить("ПоложениеЗаголовка", ПоложениеЗаголовкаЭлементаФормы.Нет);
	ПараметрыКолонкиИндикации.Вставить("Ширина",             2);
	ПараметрыКолонкиИндикации.Вставить("ВыводитьПоследней",  Ложь);
	
КонецПроцедуры

#КонецОбласти

#Область ВыполнениеПроверок

// Выполняет проверку системы согласно переданных параметров.
//
// Параметры:
//   ПараметрыПроверки - Структура, СправочникСсылка.ПравилаПроверкиУчета - Параметры проверки, 
//                       либо ссылка на проверку, которую необходимо выполнить:
//       * Идентификатор                     - Строка - Строковый идентификатор проверки.
//       * Представление                     - Строка - Пользовательское представление проверки.
//       * ИдентификаторРегламентногоЗадания - Строка - Строковый идентификатор регламентного задания,
//                                             соответствующего проверке.
//       * ДатаНачалаПроверки                - Дата - Пороговая дата, обозначающая границу проверяемых
//                                             объектов (только для объектов с датой). Объекты, дата которых
//                                             меньше указанной, не следует проверять. По умолчанию не 
//                                             заполнено (т.е. проверять все).
//       * ЛимитПроблем                      - Число - Количество проверяемых объектов.
//                                             По умолчанию 1000. Если указано 0, то следует проверить все объекты.
//
Процедура ВыполнитьПроверку(Знач ПараметрыПроверки) Экспорт
	
	Если ТипЗнч(ПараметрыПроверки) = Тип("Структура") Тогда
		Проверка = ПроверкаПоИдентификатору(ПараметрыПроверки.Идентификатор);
	Иначе
		Проверка          = ПараметрыПроверки;
		ПараметрыПроверки = ОбщегоНазначения.ЗначенияРеквизитовОбъекта(Проверка,
			"ДатаНачалаПроверки,
			|Идентификатор,
			|ИдентификаторРегламентногоЗадания,
			|ЛимитПроблем,
			|Представление");
		
		Если Не ПараметрыПроверки.Свойство("ПроверкаБылаОстановлена") Тогда
			ПараметрыПроверки.Вставить("ПроверкаБылаОстановлена", Ложь);
		КонецЕсли;
		Если Не ПараметрыПроверки.Свойство("РучнойЗапуск") Тогда
			ПараметрыПроверки.Вставить("РучнойЗапуск", Истина);
		КонецЕсли;
		
	КонецЕсли;
	
	Если ПроверкаОтложена(ПараметрыПроверки.ИдентификаторРегламентногоЗадания) Тогда
		Возврат;
	КонецЕсли;
	
	ПодготовитьДанныеПроверки(Проверка, ПараметрыПроверки);
	
	ПараметрыОбработчика = Новый Массив;
	ПараметрыОбработчика.Добавить(Проверка);
	ПараметрыОбработчика.Добавить(ПараметрыПроверки);
	
	ПроверкиВеденияУчета = КонтрольВеденияУчетаПовтИсп.ПроверкиВеденияУчета();
	Проверки             = ПроверкиВеденияУчета.Проверки;
	СтрокаПроверки       = Проверки.Найти(ПараметрыПроверки.Идентификатор, "Идентификатор");
	
	Если СтрокаПроверки <> Неопределено Тогда
		
		КонтрольВеденияУчетаПереопределяемый.ПриВыполненииПроверки(Проверка, ПараметрыПроверки);
		
		Если Не СтрокаПроверки.БезОбработчикаПроверки Тогда
			ОбщегоНазначения.ВыполнитьМетодКонфигурации(СтрокаПроверки.ОбработчикПроверки, ПараметрыОбработчика);
		КонецЕсли;
		
		КонтрольВеденияУчетаПереопределяемый.ПослеВыполненияПроверки(Проверка, ПараметрыПроверки);
		
	КонецЕсли;
	
КонецПроцедуры

// Обработчик регламентного задания "ПроверкаВеденияУчета". Предназначен для обработки
// фонового запуска проверок системы.
//   Параметры:
//     ИдентификаторРегламентногоЗадания - Строка, Неопределено - Строковый идентификатор регламентного задания.
//
Процедура ПроверитьВедениеУчета(ИдентификаторРегламентногоЗадания = Неопределено) Экспорт
	
	ОбщегоНазначения.ПриНачалеВыполненияРегламентногоЗадания(Метаданные.РегламентныеЗадания.ПроверкаВеденияУчета);
	
	Если ИдентификаторРегламентногоЗадания <> Неопределено Тогда
		
		ПараметрыПроверки = ПараметрыПроверкиПоИдентификаторуРегламентногоЗадания(ИдентификаторРегламентногоЗадания);
		Если ПараметрыПроверки <> Неопределено Тогда
			ВыполнитьПроверку(ПараметрыПроверки);
		КонецЕсли;
		
	Иначе
		
		Запрос = Новый Запрос(
		"ВЫБРАТЬ
		|	ПравилаПроверкиУчета.Идентификатор КАК Идентификатор,
		|	ПравилаПроверкиУчета.Наименование КАК Наименование,
		|	ПравилаПроверкиУчета.ИдентификаторРегламентногоЗадания КАК ИдентификаторРегламентногоЗадания,
		|	ПравилаПроверкиУчета.ДатаНачалаПроверки КАК ДатаНачалаПроверки,
		|	ПравилаПроверкиУчета.ЛимитПроблем КАК ЛимитПроблем,
		|	ПравилаПроверкиУчета.СпособВыполнения КАК СпособВыполнения
		|ИЗ
		|	Справочник.ПравилаПроверкиУчета КАК ПравилаПроверкиУчета
		|ГДЕ
		|	ПравилаПроверкиУчета.СпособВыполнения = ЗНАЧЕНИЕ(Перечисление.СпособВыполненияПроверки.ПоОбщемуРасписанию)
		|	И ПравилаПроверкиУчета.Использование");
		
		Результат = Запрос.Выполнить().Выбрать();
		Пока Результат.Следующий() Цикл
			
			ПараметрыПроверки = Новый Структура;
			ПараметрыПроверки.Вставить("Идентификатор",                     Результат.Идентификатор);
			ПараметрыПроверки.Вставить("Представление",                     Результат.Наименование);
			ПараметрыПроверки.Вставить("ИдентификаторРегламентногоЗадания", Результат.ИдентификаторРегламентногоЗадания);
			ПараметрыПроверки.Вставить("ДатаНачалаПроверки",                Результат.ДатаНачалаПроверки);
			ПараметрыПроверки.Вставить("ЛимитПроблем",                      Результат.ЛимитПроблем);
			ПараметрыПроверки.Вставить("СпособВыполнения",                  Результат.СпособВыполнения);
			ПараметрыПроверки.Вставить("ПроверкаБылаОстановлена",           Ложь);
			ПараметрыПроверки.Вставить("РучнойЗапуск",                      Ложь);
			
			ВыполнитьПроверку(ПараметрыПроверки);
			
		КонецЦикла;
		
	КонецЕсли;
	
КонецПроцедуры

// Выполнение массива проверок по переданным параметрам.
// Параметры:
//   ПараметрыПроверки - Массив - Массив, состоящий из структур вида:
//     Элемент массива - Структура Параметры проверки которую необходимо выполнить, либо массив
//                       аналогичных структур (если нужно пакетное исполнение):
//       * Идентификатор                     - Строка - Строковый идентификатор проверки.
//       * Представление                     - Строка - Пользовательское представление проверки.
//       * ИдентификаторРегламентногоЗадания - Строка - Строковый идентификатор регламентного задания,
//                                             соответствующего проверке.
//       * ДатаНачалаПроверки                - Дата - Пороговая дата, обозначающая границу проверяемых
//                                             объектов (только для объектов с датой). Объекты, дата которых
//                                             меньше указанной, не следует проверять. По умолчанию не 
//                                             заполнено (т.е. проверять все).
//       * ЛимитПроблем                      - Число - Количество проверяемых объектов.
//                                             По умолчанию 1000. Если указано 0, то следует проверить все объекты.
//   АдресХранилища - Строка - Адрес во временном хранилище для размещения результата.
//
Процедура ВыполнитьПроверкиВФоновомЗадании(Знач ПараметрыПроверки, АдресХранилища = Неопределено) Экспорт
	
	МассивПараметров = ПараметрыПроверки.МассивПараметров;
	Для Каждого ПараметрыПроверки Из МассивПараметров Цикл
		ВыполнитьПроверку(ПараметрыПроверки);
	КонецЦикла;
	
КонецПроцедуры

// См. КонтрольВеденияУчетаПереопределяемый.ПроверкаПоИдентификатору.
Функция ПроверкаПоИдентификатору(Идентификатор) Экспорт
	
	Запрос = Новый Запрос(
	"ВЫБРАТЬ
	|	ПравилаПроверкиУчета.Ссылка КАК Проверка
	|ИЗ
	|	Справочник.ПравилаПроверкиУчета КАК ПравилаПроверкиУчета
	|ГДЕ
	|	ПравилаПроверкиУчета.Идентификатор = &Идентификатор");
	
	Запрос.УстановитьПараметр("Идентификатор", Идентификатор);
	Результат = Запрос.Выполнить().Выбрать();
	
	Если Не Результат.Следующий() Тогда
		Возврат Справочники.ПравилаПроверкиУчета.ПустаяСсылка();
	Иначе
		Возврат Результат.Проверка;
	КонецЕсли;
	
КонецФункции

#КонецОбласти

#Область РазмещениеВТекущихДелах

Процедура ПриЗаполненииСпискаТекущихДел(ТекущиеДела) Экспорт
	
	Если Не КонтрольВеденияУчета.ПодсистемаДоступна() Тогда
		Возврат;
	КонецЕсли;
	
	Проблемы = КонтрольВеденияУчета.СводнаяИнформацияПоВидамПроверки("СистемныеПроверки");
	
	Если Проблемы.Количество > 0 Тогда
		
		Дело = ТекущиеДела.Добавить();
		Дело.Идентификатор  = "Администрирование";
		Дело.ЕстьДела       = Истина;
		Дело.Представление  = НСтр("ru = 'Некорректные данные'");
		Дело.Важное         = Проблемы.ЕстьОшибки;
		Дело.Количество     = Проблемы.Количество;
		Дело.ПараметрыФормы = Проблемы;
		Дело.Форма          = "Отчет.РезультатыПроверкиУчета.Форма";
		Дело.Владелец       = Метаданные.Подсистемы.Администрирование;
		
	КонецЕсли;
	
КонецПроцедуры

#КонецОбласти

#Область ПроцедурыИФункцииОбщегоНазначения

// См. КонтрольВеденияУчетаПереопределяемый.ПриОпределенииНастроек.
Функция ГлобальныеНастройки() Экспорт
	
	Настройки = Новый Структура;
	
	Настройки.Вставить("КартинкаИндикатораПроблем",    БиблиотекаКартинок.Предупреждение);
	Настройки.Вставить("ПояснениеИндикатораПроблем",   Неопределено);
	Настройки.Вставить("ГиперссылкаИндикатораПроблем", Неопределено);
	
	КонтрольВеденияУчетаПереопределяемый.ПриОпределенииНастроек(Настройки);
	
	Возврат Настройки;
	
КонецФункции

// Возвращает массив проблемных объектов. Максимально "облегчена" для прироста производительности.
//
//  Параметры:
//    КлючиСтрок - Массив - Массив, содержащий все ключи строк динамического списка.
//
//  Возвращаемое значение - Массив из ЛюбаяСсылка - массив проблемных объектов.
//
Функция ПроблемныеОбъекты(КлючиСтрок) Экспорт
	
	ТекущийПользовательПолноправный = Пользователи.ЭтоПолноправныйПользователь();
	
	Запрос = Новый Запрос(
	"ВЫБРАТЬ РАЗЛИЧНЫЕ
	|	РезультатыПроверкиУчета.ПроблемныйОбъект КАК ПроблемныйОбъект
	|ИЗ
	|	РегистрСведений.РезультатыПроверкиУчета КАК РезультатыПроверкиУчета
	|ГДЕ
	|	РезультатыПроверкиУчета.ПроблемныйОбъект В(&СписокОбъектов)
	|	И НЕ РезультатыПроверкиУчета.ИгнорироватьПроблему");
	Запрос.УстановитьПараметр("СписокОбъектов", КлючиСтрок);
	
	Если Не ТекущийПользовательПолноправный Тогда
		УстановитьПривилегированныйРежим(Истина);
	КонецЕсли;
	
	ПроблемныеОбъекты = Запрос.Выполнить().Выгрузить().ВыгрузитьКолонку("ПроблемныйОбъект");
	
	Если Не ТекущийПользовательПолноправный Тогда
		УстановитьПривилегированныйРежим(Ложь);
	КонецЕсли;
	
	Запрос = Неопределено;
	
	Возврат ПроблемныеОбъекты;
	
КонецФункции

// См. КонтрольВеденияУчета.ОписаниеПроблемы.
Функция ОписаниеПроблемы(ПроблемныйОбъект, ПараметрыПроверки) Экспорт
	
	СтруктураЗаписи = Новый Структура;
	
	СтруктураЗаписи.Вставить("ПроблемныйОбъект",         ПроблемныйОбъект);
	СтруктураЗаписи.Вставить("ПравилоПроверки",          ПараметрыПроверки.Проверка);
	СтруктураЗаписи.Вставить("ВидПроверки",              ПараметрыПроверки.ВидПроверки);
	СтруктураЗаписи.Вставить("ВажностьПроблемы",         ПараметрыПроверки.ВажностьПроблемы);
	СтруктураЗаписи.Вставить("УточнениеПроблемы",        "");
	СтруктураЗаписи.Вставить("КлючУникальности",         Новый УникальныйИдентификатор);
	СтруктураЗаписи.Вставить("Выявлено",                 ТекущаяДатаСеанса());
	СтруктураЗаписи.Вставить("ДополнительнаяИнформация", Новый ХранилищеЗначения(Неопределено));
	СтруктураЗаписи.Вставить("Ответственный",            Неопределено);
	
	Возврат СтруктураЗаписи;
	
КонецФункции

// См. КонтрольВеденияУчета.ЗаписатьПроблему.
Процедура ЗаписатьПроблему(ОшибкаПроверки, ПараметрыПроверки = Неопределено) Экспорт
	
	Если ПараметрыПроверки <> Неопределено И ЭтоПоследняяИтерацияПроверки(ПараметрыПроверки) Тогда
		Возврат;
	КонецЕсли;
	
	ПроблемныйОбъект    = ОшибкаПроверки.ПроблемныйОбъект;
	КоллекцияРеквизитов = ОшибкаПроверки.ПроблемныйОбъект.Метаданные().Реквизиты;
	
	КонтрольВеденияУчетаПереопределяемый.ПередЗаписьюПроблемы(ОшибкаПроверки, ПроблемныйОбъект, КоллекцияРеквизитов);
	
	НаборЗаписей = РегистрыСведений.РезультатыПроверкиУчета.СоздатьНаборЗаписей();
	
	Отбор        = НаборЗаписей.Отбор;
	Отбор.ВидПроверки.Установить(ОшибкаПроверки.ВидПроверки);
	Отбор.ПравилоПроверки.Установить(ОшибкаПроверки.ПравилоПроверки);
	Отбор.ПроблемныйОбъект.Установить(ПроблемныйОбъект);
	Отбор.КлючУникальности.Установить(ОшибкаПроверки.КлючУникальности);
	
	НоваяЗапись = НаборЗаписей.Добавить();
	ЗаполнитьЗначенияСвойств(НоваяЗапись, ОшибкаПроверки);
	
	НаборЗаписей.Записать();
	
КонецПроцедуры

// Выполняет проверку является ли текущий объект метаданных разделенным.
// Проверка проводится лишь в случае если разделение возможно и включено.
//
// Параметры:
//    ПолноеИмя - Строка - Полное имя объекта метаданных, который будет проверяться на
//                         возможную разделяемость.
// Возвращаемое значение:
//   Булево - Является ли переданный объект метаданных разделяемым.
//
Функция ЭтоНеразделенныйОбъектМетаданных(ПолноеИмя) Экспорт
	
	Если ОбщегоНазначения.ПодсистемаСуществует("СтандартныеПодсистемы.РаботаВМоделиСервиса") Тогда
		
		Если Метаданные.НайтиПоПолномуИмени(ПолноеИмя) = Неопределено Тогда
			Возврат Ложь;
		КонецЕсли;
		
		МодульРаботаВМоделиСервиса = ОбщегоНазначения.ОбщийМодуль("РаботаВМоделиСервиса");
		Возврат Не МодульРаботаВМоделиСервиса.ЭтоРазделенныйОбъектМетаданных(ПолноеИмя);
		
	КонецЕсли;
	
	Возврат Ложь;
	
КонецФункции

#КонецОбласти

#КонецОбласти

#Область СлужебныеПроцедурыИФункции

#Область СинхронизацияСправочникаВидовПроверокСлужебная

// Находит существующий, либо создает новый элемент справочника видов проверки.
// В процессе ставит управляемую блокировку (во избежание конфликтов при выполнении
// разными регламентными заданиями).
//
// Параметры:
//   ПараметрыПроверки - Структура - Параметры проверки которую необходимо выполнить:
//       * Идентификатор                     - Строка - Строковый идентификатор проверки.
//       * Представление                     - Строка - Пользовательское представление проверки.
//       * ИдентификаторРегламентногоЗадания - Строка - Строковый идентификатор регламентного задания,
//                                             соответствующего проверке.
//       * ПараметрыСинхронизации            - Структура, с элементами Любого типа. По свойствам этой
//                                             структуры будет производиться поиск.
//       * ДатаНачалаПроверки                - Дата - Пороговая дата, обозначающая границу проверяемых
//                                             объектов (только для объектов с датой). Объекты, дата которых
//                                             меньше указанной, не следует проверять. По умолчанию не 
//                                             заполнено (т.е. проверять все).
//       * ЛимитПроблем                      - Число - Количество проверяемых объектов.
//                                             По умолчанию 1000. Если указано 0, то следует проверить все объекты.
//       * ИтерацияПроверки                  - Число - Очередная итерация проверки. Используется совместно с параметром
//                                             ЛимитПроблем для определения предельного количества итераций.
//       * Проверка                          - СправочникСсылка.ПравилаПроверкиУчета - Ссылка на
//                                             выполненную проверку.
//       * ВидПроверки                       - СправочникСсылка.ВидыПроверок - Ссылка на вид проверки, к
//                                             которому относится выполненная проверка.
//       * ВажностьПроблемы                  - ПеречислениеСсылка.ВажностьПроблемыУчета - Важность проблемы учета
//                                             "Информация", "Предупреждение", "Ошибка" и "ПолезныйСовет".
//   КоличествоСвойств - Число - Количество свойств по которым нужно вести поиск.
//
// Возвращаемое значение - СправочникСсылка.ВидыПроверок - Найденный, либо созданный элемент справочника.
//
Функция СинхронизацияВидаПроверки(ПараметрыПроверки)
	
	БлокировкаВидаПроверок = БлокировкаВидовПроверок(ПараметрыПроверки);
	
	НачатьТранзакцию();
	Попытка
		БлокировкаВидаПроверок.Заблокировать();
		
		ПараметрыСинхронизации = ПараметрыПроверки.ПараметрыСинхронизации;
		Если ПараметрыСинхронизации.Количество() > КоличествоСвойств() Тогда
			ВидПроверкиМассив = РасширенныйПоискВидаПроверки(ПараметрыСинхронизации, КоличествоСвойств());
		Иначе
			ВидПроверкиМассив = ОбычныйПоискВидаПроверки(ПараметрыСинхронизации);
		КонецЕсли;
		
		Если ВидПроверкиМассив.Количество() = 0 Тогда
			ВидПроверки = НовыйВидПроверки(ПараметрыПроверки);
		Иначе
			ВидПроверки = ВидПроверкиМассив.Получить(0);
		КонецЕсли;
		
		ЗафиксироватьТранзакцию();
	Исключение
		ОтменитьТранзакцию();
		
		ТекстСообщения = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru = 'Не удалось записать вид проверки %1 по причине %2'"),
			ПараметрыПроверки.Идентификатор, ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
		
		ЗаписьЖурналаРегистрации(ОбновлениеИнформационнойБазы.СобытиеЖурналаРегистрации(), УровеньЖурналаРегистрации.Ошибка,
			Метаданные.Справочники.ВидыПроверок, ПараметрыПроверки.Идентификатор, ТекстСообщения);
	КонецПопытки;
	
	Возврат ВидПроверки;
	
КонецФункции

// Инициализирует и упорядочивает параметры синхронизации для поиска соответствующего
// элемента справочника "ВидыПроверок".
//
// Параметры:
//   ПараметрыПроверки - Структура - Параметры проверки которую необходимо выполнить:
//       * Идентификатор                     - Строка - Строковый идентификатор проверки.
//       * Представление                     - Строка - Пользовательское представление проверки.
//       * ИдентификаторРегламентногоЗадания - Строка - Строковый идентификатор регламентного задания,
//                                             соответствующего проверке.
//       * ПараметрыСинхронизации            - Структура, с элементами Любого типа. По свойствам этой
//                                             структуры будет производиться поиск.
//       * ДатаНачалаПроверки                - Дата - Пороговая дата, обозначающая границу проверяемых
//                                             объектов (только для объектов с датой). Объекты, дата которых
//                                             меньше указанной, не следует проверять. По умолчанию не 
//                                             заполнено (т.е. проверять все).
//       * ЛимитПроблем                      - Число - Количество проверяемых объектов.
//                                             По умолчанию 1000. Если указано 0, то следует проверить все объекты.
//       * Проверка                          - СправочникСсылка.ПравилаПроверкиУчета - Ссылка на
//                                             выполненную проверку.
//       * ВидПроверки                       - СправочникСсылка.ВидыПроверок - Ссылка на вид проверки, к
//                                             которому относится выполненная проверка.
//       * ВажностьПроблемы                  - ПеречислениеСсылка.ВажностьПроблемыУчета - Важность проблемы учета
//                                             "Информация", "Предупреждение", "Ошибка" и "ПолезныйСовет".
//   КоличествоСвойств - Число - Количество свойств по которым нужно вести поиск.
//
// Возвращаемое значение - Структура, Неопределено - Дополненная структура параметров проверки, либо неопределено
//                         в случае отсутствия элементов "ПараметрыСинхронизации" и "Идентификатор" в параметрах
//                         проверки.
//
Функция ПараметрыСинхронизацииВидаПроверок(ПараметрыПроверки)
	
	Если Не ПараметрыПроверки.Свойство("ПараметрыСинхронизации") Или Не ПараметрыПроверки.Свойство("Идентификатор") Тогда
		Возврат Неопределено;
	Иначе
		
		ПараметрыСинхронизации = ПараметрыПроверки.ПараметрыСинхронизации;
		
		ТаблицаУпорядочивания = Новый ТаблицаЗначений;
		ТаблицаУпорядочивания.Колонки.Добавить("Свойство");
		
		Для Каждого ПараметрПоиска Из ПараметрыСинхронизации Цикл
			ЗаполнитьЗначенияСвойств(ТаблицаУпорядочивания.Добавить(), Новый Структура("Свойство", ПараметрПоиска.Значение));
		КонецЦикла;
		
		ТаблицаУпорядочивания.Сортировать("Свойство");
		СтрокаИдентификатора = ТаблицаУпорядочивания.Вставить(0);
		СтрокаИдентификатора.Свойство = ПараметрыПроверки.Идентификатор;
		
		ПараметрыСинхронизации.Очистить();
		
		Для Каждого ТекущаяСтрока Из ТаблицаУпорядочивания Цикл
			ПараметрыСинхронизации.Вставить("Свойство" + Формат(ТаблицаУпорядочивания.Индекс(ТекущаяСтрока) + 1, "ЧГ=0"), ТекущаяСтрока.Свойство);
		КонецЦикла;
		
		Возврат ПараметрыПроверки;
		
	КонецЕсли;
	
КонецФункции

// Производит поиск вида проверки по переданным параметрам. Под "расширенным" понимать простой
// поиск плюс поиск по строкам табличной части "СвойстваОбъекта" справочника "ВидыПроверок".
// Данный поиск осуществляется если параметр  "КоличествоСвойств" принимает значения от 5 до N,
// где N-любое натуральное.
//
// Параметры:
//   ПараметрыСинхронизации - Структура - Параметры по которым будет производиться поиск вида проверок:
//       * Свойство1 - ЛюбаяСсылка - Первое свойство синхронизации.
//       * Свойство2 - ЛюбаяСсылка - Второе свойство синхронизации.
//       * Свойство3 - ЛюбаяСсылка - Третье свойство синхронизации.
//                               ...                              
//       * СвойствоN - ЛюбаяСсылка - N-ое свойство синхронизации.
//
//   КоличествоСвойств - Число - Количество свойств по которым нужно вести поиск.
//
// Возвращаемое значение: СправочникСсылка.ВидыПроверок - Найденный элемент справочника, либо пустая ссылка
//                        в случае если поиск не дал результата.
//
Функция РасширенныйПоискВидаПроверки(ПараметрыСинхронизации, КоличествоСвойств)
	
	Запрос = Новый Запрос(
	"ВЫБРАТЬ
	|	ВидыПроверок.Ссылка КАК ВидПроверки
	|ПОМЕСТИТЬ ВТ_ВидыПроверок
	|ИЗ
	|	Справочник.ВидыПроверок КАК ВидыПроверок
	|ГДЕ
	|	&Условие
	|
	|СГРУППИРОВАТЬ ПО
	|	ВидыПроверок.Ссылка
	|
	|ИМЕЮЩИЕ
	|	КОЛИЧЕСТВО(ВидыПроверок.СвойстваОбъекта.Ссылка) = &ПороговоеКоличество
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|ВЫБРАТЬ
	|	ВидыПроверокСвойстваОбъекта.Ссылка КАК ВидПроверки,
	|	ВидыПроверокСвойстваОбъекта.ЗначениеСвойства КАК ЗначениеСвойства,
	|	ВидыПроверокСвойстваОбъекта.ИмяСвойства КАК ИмяСвойства
	|ИЗ
	|	ВТ_ВидыПроверок КАК ВТ_ВидыПроверок
	|		ВНУТРЕННЕЕ СОЕДИНЕНИЕ Справочник.ВидыПроверок.СвойстваОбъекта КАК ВидыПроверокСвойстваОбъекта
	|		ПО ВТ_ВидыПроверок.ВидПроверки = ВидыПроверокСвойстваОбъекта.Ссылка
	|
	|УПОРЯДОЧИТЬ ПО
	|	ВидПроверки");
	
	ТекстУсловий           = " Истина ";
	КоличествоПараметров   = ПараметрыСинхронизации.Количество();
	Запрос.УстановитьПараметр("ПороговоеКоличество", КоличествоПараметров - КоличествоСвойств);
	
	Для Индекс = 1 По КоличествоСвойств Цикл
		
		Свойство  = "Свойство" + Формат(Индекс, "ЧГ=0");
		Значение  = ПараметрыСинхронизации[Свойство];
		
		ТекстУсловий = ТекстУсловий + " И " + Свойство + " = &" + Свойство;
		Запрос.УстановитьПараметр(Свойство, Значение);
		
	КонецЦикла;
	
	Запрос.Текст = СтрЗаменить(Запрос.Текст, "&Условие", ТекстУсловий);
	Результат = Запрос.Выполнить().Выгрузить();
	
	ТранспонированнаяТаблица = Новый ТаблицаЗначений;
	КолонкиТаблицы           = ТранспонированнаяТаблица.Колонки;
	КолонкиТаблицы.Добавить("ВидПроверки", Новый ОписаниеТипов("СправочникСсылка.ВидыПроверок"));
	
	СтруктураПоиска = Новый Структура;
	ИндексПоиска    = "";
	
	Для ПороговыйИндекс = КоличествоСвойств + 1 По КоличествоПараметров Цикл
		
		ИмяКолонки   = "Свойство" + Формат(ПороговыйИндекс, "ЧГ=0");
		ИндексПоиска = ИндексПоиска + ?(ЗначениеЗаполнено(ИндексПоиска), ", ", "") + ИмяКолонки;
		КолонкиТаблицы.Добавить(ИмяКолонки);
		
		СтруктураПоиска.Вставить(ИмяКолонки, ПараметрыСинхронизации[ИмяКолонки]);
		
	КонецЦикла;
	
	ТекущийВидПроверки = Неопределено;
	Для Каждого СтрокаРезультата Из Результат Цикл
		
		Если ТекущийВидПроверки <> СтрокаРезультата.ВидПроверки Тогда
			
			ТекущийВидПроверки = СтрокаРезультата.ВидПроверки;
			НоваяСтрока = ТранспонированнаяТаблица.Добавить();
			НоваяСтрока.ВидПроверки = ТекущийВидПроверки;
			
		КонецЕсли;
		
		НоваяСтрока[СтрокаРезультата.ИмяСвойства] = СтрокаРезультата.ЗначениеСвойства;
		
	КонецЦикла;
	
	Если ТранспонированнаяТаблица.Количество() > 1000 Тогда
		ТранспонированнаяТаблица.Индексы.Добавить(ИндексПоиска);
	КонецЕсли;
	
	НайденныеСтроки     = ТранспонированнаяТаблица.НайтиСтроки(СтруктураПоиска);
	МассивВидовПроверок = Новый Массив;
	Для Каждого НайденнаяСтрока Из НайденныеСтроки Цикл
		МассивВидовПроверок.Добавить(НайденнаяСтрока.ВидПроверки);
	КонецЦикла;
	
	Возврат МассивВидовПроверок;
	
КонецФункции

Функция БлокировкаВидовПроверок(ПараметрыПроверки)
	
	БлокировкаДанных = Новый БлокировкаДанных;
	ЭлементБлокировкиДанных = БлокировкаДанных.Добавить("Справочник.ВидыПроверок");
	
	ПараметрыСинхронизации = ПараметрыПроверки.ПараметрыСинхронизации;
	
	Если Не (ОбщегоНазначения.ИнформационнаяБазаФайловая()
		Или ПараметрыСинхронизации.Количество() > КоличествоСвойств()) Тогда
		Индекс = 1;
		Для Каждого ПараметрПоиска Из ПараметрыСинхронизации Цикл
			ЭлементБлокировкиДанных.УстановитьЗначение("Свойство" + Формат(Индекс, "ЧГ=0"), ПараметрПоиска.Значение);
			Индекс = Индекс + 1;
		КонецЦикла;
	КонецЕсли;
	
	Возврат БлокировкаДанных;
	
КонецФункции

// Производит поиск вида проверки по переданным параметрам. Под "обычным" поиском понимать 
// поиск в справочнике "ВидыПроверок" только по реквизитам шапки с именами СвойствоN, где N от 1
// до возврата функции "КоличествоСвойств" текущего модуля. Данный поиск осуществляется если
// указанный параметр принимает значения от 1 до "КоличествоСвойств".
//
// Параметры:
//   ПараметрыСинхронизации - Структура - Параметры по которым будет производиться поиск вида проверок:
//      * Свойство1 - ЛюбаяСсылка - Первое свойство синхронизации.
//      * Свойство2 - ЛюбаяСсылка - Второе свойство синхронизации.
//      * Свойство3 - ЛюбаяСсылка - Третье свойство синхронизации.
//                               ...                             
//      * СвойствоN - ЛюбаяСсылка - N-ое свойство синхронизации.
//   КоличествоСвойств          - Число - Количество свойств по которым нужно вести поиск.
//   ПоискПоТочномуСоответствию - Булево - Регулирует возможности точности. Если Истина, то поиск ведется
//                                по переданным свойствам на равенство, остальные свойства должны быть равны
//                                Неопределено (табличная часть дополнительных свойств должна быть пуста).
//                                Если Ложь, то значения остальных свойств могут быть произвольными, главное
//                                чтобы соответствующие свойства были равны свойствам структуры. По умолчанию Истина.
//
// Возвращаемое значение: СправочникСсылка.ВидыПроверок - Найденный элемент справочника, либо пустая ссылка
//                        в случае если поиск не дал результата.
//
Функция ОбычныйПоискВидаПроверки(ПараметрыСинхронизации, ПоискПоТочномуСоответствию = Истина)
	
	Запрос = Новый Запрос(
	"ВЫБРАТЬ
	|	ВидыПроверок.Ссылка КАК ВидПроверки
	|ИЗ
	|	Справочник.ВидыПроверок КАК ВидыПроверок
	|ГДЕ
	|	&Условие
	|
	|СГРУППИРОВАТЬ ПО
	|	ВидыПроверок.Ссылка
	|
	|ИМЕЮЩИЕ
	|	КОЛИЧЕСТВО(ВидыПроверок.СвойстваОбъекта.Ссылка) = 0");
	
	ТекстУсловий         = " Истина ";
	КоличествоПараметров = ПараметрыСинхронизации.Количество();
	КоличествоСвойств    = КоличествоСвойств();
	
	Для Индекс = 1 По КоличествоСвойств Цикл
		
		Свойство = "Свойство" + Формат(Индекс, "ЧГ=0");
		Если Индекс > КоличествоПараметров Тогда
			Если ПоискПоТочномуСоответствию Тогда
				ТекстУсловий = ТекстУсловий + " И " + Свойство + " = Неопределено";
			КонецЕсли;
		Иначе
			Значение     = ПараметрыСинхронизации[Свойство];
			
			ТекстУсловий = ТекстУсловий + " И " + Свойство + " = &" + Свойство;
			Запрос.УстановитьПараметр(Свойство, Значение);
		КонецЕсли;
		
	КонецЦикла;
	
	Запрос.Текст = СтрЗаменить(Запрос.Текст, "&Условие", ТекстУсловий);
	Результат = Запрос.Выполнить().Выгрузить();
	
	Возврат Результат.ВыгрузитьКолонку("ВидПроверки");
	
КонецФункции

Функция НовыйВидПроверки(ПараметрыПроверки)
	
	ПараметрыСинхронизации = ПараметрыПроверки.ПараметрыСинхронизации;
	
	НовыйВидПроверки = Справочники.ВидыПроверок.СоздатьЭлемент();
	Если ЗначениеЗаполнено(ПараметрыПроверки.Представление) Тогда
		НовыйВидПроверки.Наименование = ПараметрыПроверки.Представление;
	Иначе
		НовыйВидПроверки.Наименование = ПараметрыСинхронизации.Свойство1;
	КонецЕсли;
	
	ПредставлениеСсылки = НовыйВидПроверки.Наименование;
	
	КоличествоСвойств    = КоличествоСвойств();
	КоличествоПараметров = ПараметрыСинхронизации.Количество();
	
	Если КоличествоСвойств > КоличествоПараметров Тогда
		Для Индекс = 1 По КоличествоПараметров Цикл
			ИмяСвойства = "Свойство" + Формат(Индекс, "ЧГ=0");
			НовыйВидПроверки[ИмяСвойства] = ПараметрыСинхронизации[ИмяСвойства];
			Если Индекс > 1 Тогда
				ПредставлениеСсылки = ПредставлениеСсылки + ", " + Строка(ПараметрыСинхронизации[ИмяСвойства]);
			КонецЕсли;
		КонецЦикла;
	Иначе
		Для Индекс = 1 По КоличествоПараметров Цикл
			ИмяСвойства = "Свойство" + Формат(Индекс, "ЧГ=0");
			Если Индекс <= КоличествоСвойств Тогда
				НовыйВидПроверки[ИмяСвойства] = ПараметрыСинхронизации[ИмяСвойства];
				Если Индекс > 1 Тогда
					ПредставлениеСсылки = ПредставлениеСсылки + ", " + Строка(ПараметрыСинхронизации[ИмяСвойства]);
				КонецЕсли;
			Иначе
				ЗаполнитьЗначенияСвойств(НовыйВидПроверки.СвойстваОбъекта.Добавить(),
					Новый Структура("ИмяСвойства, ЗначениеСвойства", ИмяСвойства, ПараметрыСинхронизации[ИмяСвойства]));
				Если Индекс > 1 Тогда
					ПредставлениеСсылки = ПредставлениеСсылки + ", " + Строка(ПараметрыСинхронизации[ИмяСвойства]);
				КонецЕсли;
			КонецЕсли;
		КонецЦикла;
	КонецЕсли;
	
	НовыйВидПроверки.ПредставлениеСсылки = ПредставлениеСсылки;
	НовыйВидПроверки.Записать();
	
	Возврат НовыйВидПроверки.Ссылка;
	
КонецФункции

Функция КоличествоСвойств()
	
	Возврат 5;
	
КонецФункции

#КонецОбласти

#Область СинхронизацияСправочникаПроверокСлужебная

Процедура ОбновлениеСправочникаПроверок(ГруппыПроверок, Проверки)
	
	ДобавитьГруппыПроверок(ГруппыПроверок);
	ДобавитьПроверки(Проверки);
	
КонецПроцедуры

Процедура ДобавитьГруппыПроверок(ГруппыПроверок)
	
	Для Каждого ГруппаПроверок Из ГруппыПроверок Цикл
		
		ГруппаПроверокПоИдентификатору = КонтрольВеденияУчета.ПроверкаПоИдентификатору(ГруппаПроверок.Идентификатор);
		
		Если Не ЗначениеЗаполнено(ГруппаПроверокПоИдентификатору) Тогда
			ГруппаПроверокОбъект = Справочники.ПравилаПроверкиУчета.СоздатьГруппу();
		Иначе
			
			Если ГруппаПроверокПоИдентификатору.ПроверкаВеденияУчетаИзменена Тогда
				Продолжить;
			КонецЕсли;
			
			ГруппаПроверокОбъект = ГруппаПроверокПоИдентификатору.ПолучитьОбъект();
			Если ГруппаПроверокПоИдентификатору.ПометкаУдаления Тогда
				ГруппаПроверокОбъект.УстановитьПометкуУдаления(Ложь);
			КонецЕсли;
			
		КонецЕсли;
		
		ЗаполнитьЗначенияСвойств(ГруппаПроверокОбъект, ГруппаПроверок);
		ОбновлениеИнформационнойБазы.ЗаписатьДанные(ГруппаПроверокОбъект);
		
	КонецЦикла;
	
	Запрос = Новый Запрос(
	"ВЫБРАТЬ
	|	ГруппыПроверок.Идентификатор КАК Идентификатор,
	|	ГруппыПроверок.Наименование КАК Наименование
	|ПОМЕСТИТЬ ВТ_ГруппыПроверок
	|ИЗ
	|	&ГруппыПроверок КАК ГруппыПроверок
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|ВЫБРАТЬ
	|	ПравилаПроверкиУчета.Ссылка КАК Ссылка
	|ИЗ
	|	Справочник.ПравилаПроверкиУчета КАК ПравилаПроверкиУчета
	|		ЛЕВОЕ СОЕДИНЕНИЕ ВТ_ГруппыПроверок КАК ВТ_ГруппыПроверок
	|		ПО ПравилаПроверкиУчета.Идентификатор = ВТ_ГруппыПроверок.Идентификатор
	|ГДЕ
	|	ВТ_ГруппыПроверок.Наименование ЕСТЬ NULL
	|	И ПравилаПроверкиУчета.ЭтоГруппа
	|	И НЕ ПравилаПроверкиУчета.Предопределенный
	|	И НЕ ПравилаПроверкиУчета.ПроверкаВеденияУчетаИзменена");
	
	Запрос.МенеджерВременныхТаблиц = Новый МенеджерВременныхТаблиц;
	Запрос.УстановитьПараметр("ГруппыПроверок", ГруппыПроверок);
	
	Результат = Запрос.Выполнить().Выбрать();
	Пока Результат.Следующий() Цикл
		ГруппаПроверокОбъект = Результат.Ссылка.ПолучитьОбъект();
		ГруппаПроверокОбъект.УстановитьПометкуУдаления(Истина);
	КонецЦикла;
	
	Запрос.МенеджерВременныхТаблиц.Закрыть();
	Запрос = Неопределено;
	
КонецПроцедуры

Процедура ДобавитьПроверки(Проверки)
	
	Для Каждого Проверка Из Проверки Цикл
		
		ПроверкаПоИдентификатору = КонтрольВеденияУчета.ПроверкаПоИдентификатору(Проверка.Идентификатор);
		Если Не ЗначениеЗаполнено(ПроверкаПоИдентификатору) Тогда
			
			ПроверкаОбъект = Справочники.ПравилаПроверкиУчета.СоздатьЭлемент();
			ПроверкаОбъект.СпособВыполнения = Перечисления.СпособВыполненияПроверки.ПоОбщемуРасписанию;
			ПроверкаОбъект.ВажностьПроблемы = Перечисления.ВажностьПроблемыУчета.Ошибка;
			
		Иначе
			
			Если ПроверкаПоИдентификатору.ПроверкаВеденияУчетаИзменена Тогда
				Продолжить;
			КонецЕсли;
			
			ПроверкаОбъект = ПроверкаПоИдентификатору.ПолучитьОбъект();
			Если ПроверкаПоИдентификатору.ПометкаУдаления Тогда
				ПроверкаОбъект.УстановитьПометкуУдаления(Ложь);
			КонецЕсли;
			
		КонецЕсли;
		
		ЗаполнитьЗначенияСвойств(ПроверкаОбъект, Проверка);
		
		ПроверкаОбъект.Родитель      = КонтрольВеденияУчета.ПроверкаПоИдентификатору(Проверка.ИдентификаторРодителя);
		ПроверкаОбъект.Использование = Истина;
		
		Если ЗначениеЗаполнено(Проверка.ЛимитПроблем) Тогда
			ПроверкаОбъект.ЛимитПроблем = Проверка.ЛимитПроблем;
		Иначе
			ПроверкаОбъект.ЛимитПроблем = 1000;
		КонецЕсли;
		
		Если ЗначениеЗаполнено(Проверка.ДатаНачалаПроверки) Тогда
			ПроверкаОбъект.ДатаНачалаПроверки = Проверка.ДатаНачалаПроверки;
		КонецЕсли;
		
		ОбновлениеИнформационнойБазы.ЗаписатьДанные(ПроверкаОбъект);
	КонецЦикла;
	
	Запрос = Новый Запрос(
	"ВЫБРАТЬ
	|	Проверки.Идентификатор КАК Идентификатор,
	|	Проверки.Наименование КАК Наименование
	|ПОМЕСТИТЬ ВТ_Проверки
	|ИЗ
	|	&Проверки КАК Проверки
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|ВЫБРАТЬ
	|	ПравилаПроверкиУчета.Ссылка КАК Ссылка
	|ИЗ
	|	Справочник.ПравилаПроверкиУчета КАК ПравилаПроверкиУчета
	|		ЛЕВОЕ СОЕДИНЕНИЕ ВТ_Проверки КАК ВТ_Проверки
	|		ПО ПравилаПроверкиУчета.Идентификатор = ВТ_Проверки.Идентификатор
	|ГДЕ
	|	ВТ_Проверки.Наименование ЕСТЬ NULL
	|	И НЕ ПравилаПроверкиУчета.ЭтоГруппа
	|	И НЕ ПравилаПроверкиУчета.Предопределенный
	|	И НЕ ПравилаПроверкиУчета.ПроверкаВеденияУчетаИзменена");
	
	Запрос.МенеджерВременныхТаблиц = Новый МенеджерВременныхТаблиц;
	Запрос.УстановитьПараметр("Проверки", Проверки);
	
	Результат = Запрос.Выполнить().Выбрать();
	Пока Результат.Следующий() Цикл
		ПроверкаОбъект = Результат.Ссылка.ПолучитьОбъект();
		ПроверкаОбъект.УстановитьПометкуУдаления(Истина);
	КонецЦикла;
	
	Запрос.МенеджерВременныхТаблиц.Закрыть();
	Запрос = Неопределено;
	
КонецПроцедуры

#КонецОбласти

#Область КонтрольСсылочнойЦелостности

Процедура НайтиБитыеСсылки(ОбъектМетаданных, ПараметрыПроверки)
	
	ПолноеИмя      = ОбъектМетаданных.ПолноеИмя();
	Реквизиты      = ОбъектМетаданных.Реквизиты;
	ТабличныеЧасти = ОбъектМетаданных.ТабличныеЧасти;
	
	ТекстЗапроса = "
	|ВЫБРАТЬ ПЕРВЫЕ 1000
	|	ОбъектМетаданных.Ссылка КАК Ссылка
	|ИЗ
	|	&ОбъектМетаданных КАК ОбъектМетаданных
	|ГДЕ
	|	ОбъектМетаданных.Ссылка > &Ссылка
	|
	|УПОРЯДОЧИТЬ ПО
	|	ОбъектМетаданных.Ссылка";
	ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "&ОбъектМетаданных", ПолноеИмя);
	
	Запрос = Новый Запрос(ТекстЗапроса);
	Запрос.УстановитьПараметр("Ссылка", "");
	
	Результат = Запрос.Выполнить().Выгрузить();
	
	ОграничениеПоДате = ПараметрыПроверки.ДатаНачалаПроверки;
	КэшБитыхСсылок    = Новый Массив;
	
	Пока Истина Цикл
		
		Если Результат.Количество() = 0 Тогда
			Прервать;
		КонецЕсли;
		
		Для Каждого СтрокаРезультата Из Результат Цикл
			
			СсылкаНаОбъект    = СтрокаРезультата.Ссылка;
			УточнениеПроблемы = "";
			
			Если ЗначениеЗаполнено(ОграничениеПоДате)
				И ОбщегоНазначения.ЭтоДокумент(ОбъектМетаданных)
				И ОбщегоНазначения.ЗначениеРеквизитаОбъекта(СсылкаНаОбъект, "Дата") < ОграничениеПоДате Тогда
				Продолжить;
			КонецЕсли;
			
			Для Каждого Реквизит Из Реквизиты Цикл
				
				ТекущаяСсылка = ОбщегоНазначения.ЗначениеРеквизитаОбъекта(СсылкаНаОбъект, Реквизит.Имя);
				
				Если Не ЗначениеЗаполнено(ТекущаяСсылка) Тогда
					Продолжить;
				КонецЕсли;
				
				Если КэшБитыхСсылок.Найти(ТекущаяСсылка) <> Неопределено Тогда
					
					УточнениеПроблемы = УточнениеПроблемы + ?(ЗначениеЗаполнено(УточнениеПроблемы), Символы.ПС, "")
						+ СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(НСтр("ru='У объекта ""%1"" в реквизите ""%2"" указан несуществующий элемент: ""%3"".'"), СсылкаНаОбъект, Реквизит.Имя, ТекущаяСсылка);
						
				Иначе
					
					Если Не ОбщегоНазначения.ЗначениеСсылочногоТипа(ТекущаяСсылка) Тогда
						Продолжить;
					КонецЕсли;
					
					Если Не ОбщегоНазначения.СсылкаСуществует(ТекущаяСсылка) Тогда
						
						УточнениеПроблемы = УточнениеПроблемы + ?(ЗначениеЗаполнено(УточнениеПроблемы), Символы.ПС, "")
							+ СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(НСтр("ru='У объекта ""%1"" в реквизите ""%2"" указан несуществующий элемент: ""%3"".'"), СсылкаНаОбъект, Реквизит.Имя, ТекущаяСсылка);
						КэшБитыхСсылок.Добавить(ТекущаяСсылка);
						
					КонецЕсли;
					
				КонецЕсли;
				
			КонецЦикла;
			
			Если ОбщегоНазначения.ЭтоЗадача(ОбъектМетаданных) Тогда
				
				РеквизитыАдресации = ОбъектМетаданных.РеквизитыАдресации;
				Для Каждого РеквизитАдресации Из РеквизитыАдресации Цикл
					
					ТекущаяСсылка = ОбщегоНазначения.ЗначениеРеквизитаОбъекта(СсылкаНаОбъект, РеквизитАдресации.Имя);
					
					Если Не ЗначениеЗаполнено(ТекущаяСсылка) Тогда
						Продолжить;
					КонецЕсли;
					
					Если КэшБитыхСсылок.Найти(ТекущаяСсылка) <> Неопределено Тогда
						
						УточнениеПроблемы = УточнениеПроблемы + ?(ЗначениеЗаполнено(УточнениеПроблемы), Символы.ПС, "")
							+ СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(НСтр("ru='У объекта ""%1"" в реквизите адресации ""%2"" указан несуществующий элемент: ""%3"".'"), СсылкаНаОбъект, РеквизитАдресации.Имя, ТекущаяСсылка);
						
					Иначе
						
						Если Не ОбщегоНазначения.ЗначениеСсылочногоТипа(ТекущаяСсылка) Тогда
							Продолжить;
						КонецЕсли;
						
						Если Не ОбщегоНазначения.СсылкаСуществует(ТекущаяСсылка) Тогда
							
							УточнениеПроблемы = УточнениеПроблемы + ?(ЗначениеЗаполнено(УточнениеПроблемы), Символы.ПС, "")
								+ СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(НСтр("ru='У объекта ""%1"" в реквизите адресации ""%2"" указан несуществующий элемент: ""%3"".'"), СсылкаНаОбъект, РеквизитАдресации.Имя, ТекущаяСсылка);
							КэшБитыхСсылок.Добавить(ТекущаяСсылка);
							
						КонецЕсли;
						
					КонецЕсли;
					
				КонецЦикла;
				
			КонецЕсли;
			
			Для Каждого ТабличнаяЧасть Из ТабличныеЧасти Цикл
				
				РеквизитыТабличнойЧасти = ТабличнаяЧасть.Реквизиты;
				ТекущийНомерСтроки      = 1;
				
				Для Каждого РеквизитТабличнойЧасти Из РеквизитыТабличнойЧасти Цикл
					
					ЗапросКТабличнойЧасти   = ОбщегоНазначения.ЗначениеРеквизитаОбъекта(СсылкаНаОбъект, ТабличнаяЧасть.Имя + "." + РеквизитТабличнойЧасти.Имя);
					ВыборкаИзТабличнойЧасти = ЗапросКТабличнойЧасти.Выбрать();
					
					Пока ВыборкаИзТабличнойЧасти.Следующий() Цикл
						
						ТекущаяСсылка = ВыборкаИзТабличнойЧасти[РеквизитТабличнойЧасти.Имя];
						
						Если Не ЗначениеЗаполнено(ТекущаяСсылка) Тогда
							Продолжить;
						КонецЕсли;
						
						Если КэшБитыхСсылок.Найти(ТекущаяСсылка) <> Неопределено Тогда
							
							УточнениеПроблемы = УточнениеПроблемы + ?(ЗначениеЗаполнено(УточнениеПроблемы), Символы.ПС, "")
								+ СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(НСтр("ru='У объекта ""%1"" в реквизите ""%2"" табличной части ""%3"" (строка №%4) указан несуществующий элемент: ""%5"".'"),
								СсылкаНаОбъект, РеквизитТабличнойЧасти.Имя, ТабличнаяЧасть.Имя, ТекущийНомерСтроки, ТекущаяСсылка);
							
						Иначе
							
							Если Не ОбщегоНазначения.ЗначениеСсылочногоТипа(ТекущаяСсылка) Тогда
								Продолжить;
							КонецЕсли;
							
							Если Не ОбщегоНазначения.СсылкаСуществует(ТекущаяСсылка) Тогда
								
								УточнениеПроблемы = УточнениеПроблемы + ?(ЗначениеЗаполнено(УточнениеПроблемы), Символы.ПС, "")
									+ СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(НСтр("ru='У объекта ""%1"" в реквизите ""%2"" табличной части ""%3"" (строка №%4) указан несуществующий элемент: ""%5"".'"),
									СсылкаНаОбъект, РеквизитТабличнойЧасти.Имя, ТабличнаяЧасть.Имя, ТекущийНомерСтроки, ТекущаяСсылка);
								КэшБитыхСсылок.Добавить(ТекущаяСсылка);
								
							КонецЕсли;
							
						КонецЕсли;
						
						ТекущийНомерСтроки = ТекущийНомерСтроки + 1;
						
					КонецЦикла;
					
					ЗапросКТабличнойЧасти = Неопределено;
					
				КонецЦикла;
				
			КонецЦикла;
			
			Если Не ЗначениеЗаполнено(УточнениеПроблемы) Тогда
				Продолжить;
			КонецЕсли;
			
			Проблема = ОписаниеПроблемы(СсылкаНаОбъект, ПараметрыПроверки);
			Проблема.УточнениеПроблемы = НСтр("ru = 'Обнаружено нарушение ссылочной целостности:'") + Символы.ПС + УточнениеПроблемы;
			Если Реквизиты.Найти("Ответственный") <> Неопределено Тогда
				Проблема.Вставить("Ответственный", ОбщегоНазначения.ЗначениеРеквизитаОбъекта(СсылкаНаОбъект, "Ответственный"));
			КонецЕсли;
			
			ЗаписатьПроблему(Проблема, ПараметрыПроверки);
			
		КонецЦикла;
		
		Запрос.УстановитьПараметр("Ссылка", СтрокаРезультата.Ссылка);
		Результат = Запрос.Выполнить().Выгрузить();
	КонецЦикла;
	Запрос = Неопределено;
	
КонецПроцедуры

#Область КонтрольСсылочнойЦелостностиВРегистрах

Процедура НайтиБитыеСсылкиВРегистрах(ОбъектМетаданных, ПараметрыПроверки)
	
	Если ОбъектМетаданных.Измерения.Количество() = 0 Тогда
		Возврат;
	КонецЕсли;
	
	Если ОбщегоНазначения.ЭтоРегистрНакопления(ОбъектМетаданных) Тогда
		НайтиБитыеСсылкиВРегистрахНакопления(ОбъектМетаданных, ПараметрыПроверки);
	ИначеЕсли ОбщегоНазначения.ЭтоРегистрСведений(ОбъектМетаданных) Тогда
		НайтиБитыеСсылкиВРегистрахСведений(ОбъектМетаданных, ПараметрыПроверки);
	ИначеЕсли ОбщегоНазначения.ЭтоРегистрБухгалтерии(ОбъектМетаданных) Тогда
		НайтиБитыеСсылкиВРегистрахБухгалтерии(ОбъектМетаданных, ПараметрыПроверки);
	ИначеЕсли ОбщегоНазначения.ЭтоРегистрРасчета(ОбъектМетаданных) Тогда
		НайтиБитыеСсылкиВРегистрахРасчета(ОбъектМетаданных, ПараметрыПроверки);
	КонецЕсли;
	
КонецПроцедуры

#Область КонтрольСсылочнойЦелостностиВРегистрахНакопления

Процедура НайтиБитыеСсылкиВРегистрахНакопления(ОбъектМетаданных, ПараметрыПроверки)
	
	ПолноеИмя = ОбъектМетаданных.ПолноеИмя();
	Измерения = ОбъектМетаданных.Измерения;
	Реквизиты = ОбъектМетаданных.Реквизиты;
	
	ИнформацияОМетаданных = Новый ТаблицаЗначений;
	ИнформацияОМетаданных.Колонки.Добавить("ТипМетаданныхВИминительномПадеже", Новый ОписаниеТипов("Строка", , , , Новый КвалификаторыСтроки(16)));
	ИнформацияОМетаданных.Колонки.Добавить("ТипМетаданныхВТворительномПадеже", Новый ОписаниеТипов("Строка", , , , Новый КвалификаторыСтроки(16)));
	ИнформацияОМетаданных.Колонки.Добавить("ИмяМетаданных", Новый ОписаниеТипов("Строка", , , , Новый КвалификаторыСтроки(128)));
	
	ПоляВыборки = "НомерСтроки Как НомерСтроки, Регистратор Как РегистраторРеквизитСсылка, ПредставлениеСсылки(Регистратор) Как РегистраторРеквизитПредставление";
	ЗаполнитьЗначенияСвойств(ИнформацияОМетаданных.Добавить(),
		Новый Структура("ТипМетаданныхВИминительномПадеже, ТипМетаданныхВТворительномПадеже, ИмяМетаданных", "Реквизит", НСтр("ru = 'реквизите'"), "Регистратор"));
	Для Каждого Измерение Из Измерения Цикл
		ИмяИзмерения = Измерение.Имя;
		ПоляВыборки = ПоляВыборки + "," + ИмяИзмерения + " Как " + ИмяИзмерения
			+ "ИзмерениеСсылка,ПредставлениеСсылки(" + ИмяИзмерения + ") Как " + ИмяИзмерения + "ИзмерениеПредставление";
		ЗаполнитьЗначенияСвойств(ИнформацияОМетаданных.Добавить(),
			Новый Структура("ТипМетаданныхВИминительномПадеже, ТипМетаданныхВТворительномПадеже, ИмяМетаданных", "Измерение", НСтр("ru = 'измерении'"), ИмяИзмерения));
	КонецЦикла;
	Для Каждого Реквизит Из Реквизиты Цикл
		ИмяРеквизита = Реквизит.Имя;
		ПоляВыборки = ПоляВыборки + "," + ИмяРеквизита + " Как " + ИмяРеквизита
			+ "РеквизитСсылка,ПредставлениеСсылки(" + ИмяРеквизита + ") Как " + ИмяРеквизита + "РеквизитПредставление";
		ЗаполнитьЗначенияСвойств(ИнформацияОМетаданных.Добавить(),
			Новый Структура("ТипМетаданныхВИминительномПадеже, ТипМетаданныхВТворительномПадеже, ИмяМетаданных", "Реквизит", НСтр("ru = 'реквизите'"), ИмяРеквизита));
	КонецЦикла;
	
	ТекстЗапроса =
	"ВЫБРАТЬ ПЕРВЫЕ 1000
	|	&ПоляВыборки КАК ПоляВыборки
	|ИЗ
	|	&ОбъектМетаданных КАК ОбъектМетаданных
	|ГДЕ
	|	ВЫБОР
	|			КОГДА ОбъектМетаданных.Регистратор = &Регистратор
	|				ТОГДА ОбъектМетаданных.НомерСтроки > &НомерСтроки
	|			ИНАЧЕ ОбъектМетаданных.Регистратор > &Регистратор
	|		КОНЕЦ
	|	И ОбъектМетаданных.Период > &ДатаНачалаПроверки
	|
	|УПОРЯДОЧИТЬ ПО
	|	ОбъектМетаданных.Регистратор,
	|	ОбъектМетаданных.НомерСтроки";
	
	ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "КАК ПоляВыборки", "");
	ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "&ОбъектМетаданных", ПолноеИмя);
	ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "&ПоляВыборки", ПоляВыборки);
	
	Запрос = Новый Запрос(ТекстЗапроса);
	Запрос.УстановитьПараметр("НомерСтроки",        0);
	Запрос.УстановитьПараметр("ДатаНачалаПроверки", ПараметрыПроверки.ДатаНачалаПроверки);
	Запрос.УстановитьПараметр("Регистратор",        "");
	Результат = Запрос.Выполнить().Выгрузить();
	
	КэшБитыхСсылок = Новый Массив;
	Пока Истина Цикл
		
		Если Результат.Количество() = 0 Тогда
			Прервать;
		КонецЕсли;
		
		Для Каждого СтрокаРезультата Из Результат Цикл
			
			Для Каждого ПодчиненныйОбъект Из ИнформацияОМетаданных Цикл
				
				ТекущаяСсылка     = СтрокаРезультата[ПодчиненныйОбъект.ИмяМетаданных + ПодчиненныйОбъект.ТипМетаданныхВИминительномПадеже + "Ссылка"];
				УточнениеПроблемы = "";
				
				Если Не ОбщегоНазначения.ЗначениеСсылочногоТипа(ТекущаяСсылка) Или Не ЗначениеЗаполнено(ТекущаяСсылка) Тогда
					Продолжить;
				КонецЕсли;
				
				Если КэшБитыхСсылок.Найти(ТекущаяСсылка) <> Неопределено Тогда
					
					УточнениеПроблемы = УточнениеПроблемы + ?(ЗначениеЗаполнено(УточнениеПроблемы), Символы.ПС, "")
						+ СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(НСтр("ru='У регистра накопления ""%1"" в %2, записи №%3 по регистратору ""%4"" указан несуществующий элемент: ""%5"".'"),
							ОбъектМетаданных.Представление(), ПодчиненныйОбъект.ТипМетаданныхВТворительномПадеже,
							Формат(СтрокаРезультата.НомерСтроки, "ЧГ=0"), СтрокаРезультата["РегистраторРеквизитПредставление"],
							СтрокаРезультата[ПодчиненныйОбъект.ИмяМетаданных + ПодчиненныйОбъект.ТипМетаданныхВИминительномПадеже + "Представление"]);
						
				Иначе
					
					Если Не ОбщегоНазначения.СсылкаСуществует(ТекущаяСсылка) Тогда
						
						УточнениеПроблемы = УточнениеПроблемы + ?(ЗначениеЗаполнено(УточнениеПроблемы), Символы.ПС, "")
							+ СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(НСтр("ru='У регистра накопления ""%1"" в %2, записи №%3 по регистратору ""%4"" указан несуществующий элемент: ""%5"".'"),
								ОбъектМетаданных.Представление(), ПодчиненныйОбъект.ТипМетаданныхВТворительномПадеже,
								Формат(СтрокаРезультата.НомерСтроки, "ЧГ=0"), СтрокаРезультата["РегистраторРеквизитПредставление"],
								СтрокаРезультата[ПодчиненныйОбъект.ИмяМетаданных + ПодчиненныйОбъект.ТипМетаданныхВИминительномПадеже + "Представление"]);
						КэшБитыхСсылок.Добавить(ТекущаяСсылка);
						
					КонецЕсли;
					
				КонецЕсли;
				
				Если Не ЗначениеЗаполнено(УточнениеПроблемы) Тогда
					Продолжить;
				КонецЕсли;
				
				СтруктураНабораЗаписей = Новый Структура;
				СтруктураНабораЗаписей.Вставить("Регистратор", СтрокаРезультата["РегистраторРеквизитСсылка"]);
				
				Проблема = ОписаниеПроблемы(ОбщегоНазначения.ИдентификаторОбъектаМетаданных(ОбъектМетаданных), ПараметрыПроверки);
				Проблема.УточнениеПроблемы        = НСтр("ru = 'Обнаружено нарушение ссылочной целостности:'") + Символы.ПС + УточнениеПроблемы;
				Проблема.ДополнительнаяИнформация = Новый ХранилищеЗначения(СтруктураНабораЗаписей);
				
				ЗаписатьПроблему(Проблема, ПараметрыПроверки);
				
			КонецЦикла;
			
		КонецЦикла;
		
		Запрос.УстановитьПараметр("НомерСтроки", СтрокаРезультата["НомерСтроки"]);
		Запрос.УстановитьПараметр("Регистратор", СтрокаРезультата["РегистраторРеквизитСсылка"]);
		Результат = Запрос.Выполнить().Выгрузить();
		
	КонецЦикла;
	Запрос = Неопределено;
		
КонецПроцедуры

#КонецОбласти

#Область КонтрольСсылочнойЦелостностиВРегистрахСведений

Процедура НайтиБитыеСсылкиВРегистрахСведений(ОбъектМетаданных, ПараметрыПроверки)
	
	Измерения = ОбъектМетаданных.Измерения;
	Ресурсы   = ОбъектМетаданных.Ресурсы;
	Реквизиты = ОбъектМетаданных.Реквизиты;
	
	ИнформацияОМетаданных = Новый ТаблицаЗначений;
	ИнформацияОМетаданных.Колонки.Добавить("ТипМетаданныхВИминительномПадеже", Новый ОписаниеТипов("Строка", , , , Новый КвалификаторыСтроки(16)));
	ИнформацияОМетаданных.Колонки.Добавить("ТипМетаданныхВТворительномПадеже", Новый ОписаниеТипов("Строка", , , , Новый КвалификаторыСтроки(16)));
	ИнформацияОМетаданных.Колонки.Добавить("ИмяМетаданных",                    Новый ОписаниеТипов("Строка", , , , Новый КвалификаторыСтроки(128)));
	
	ПоляВыборки = "";
	Для Каждого Измерение Из Измерения Цикл
		ИмяИзмерения = Измерение.Имя;
		ПоляВыборки  = ПоляВыборки + ?(ЗначениеЗаполнено(ПоляВыборки), ",", "") + ИмяИзмерения + " Как " + ИмяИзмерения
			+ "ИзмерениеСсылка,ПредставлениеСсылки(" + ИмяИзмерения + ") Как " + ИмяИзмерения + "ИзмерениеПредставление";
		ЗаполнитьЗначенияСвойств(ИнформацияОМетаданных.Добавить(),
			Новый Структура("ТипМетаданныхВИминительномПадеже, ТипМетаданныхВТворительномПадеже, ИмяМетаданных", "Измерение", НСтр("ru = 'измерении'"), ИмяИзмерения));
		КонецЦикла;
		
	Для Каждого Ресурс Из Ресурсы Цикл
		ИмяРесурса  = Ресурс.Имя;
		ПоляВыборки = ПоляВыборки + ?(ЗначениеЗаполнено(ПоляВыборки), ",", "") + ИмяРесурса + " Как " + ИмяРесурса
			+ "РесурсСсылка,ПредставлениеСсылки(" + ИмяРесурса + ") Как " + ИмяРесурса + "РесурсПредставление";
		ЗаполнитьЗначенияСвойств(ИнформацияОМетаданных.Добавить(),
			Новый Структура("ТипМетаданныхВИминительномПадеже, ТипМетаданныхВТворительномПадеже, ИмяМетаданных", "Ресурс", НСтр("ru = 'ресурсе'"), ИмяРесурса));
	КонецЦикла;
		
	Для Каждого Реквизит Из Реквизиты Цикл
		ИмяРеквизита = Реквизит.Имя;
		ПоляВыборки = ПоляВыборки + ?(ЗначениеЗаполнено(ПоляВыборки), ",", "") + ИмяРеквизита + " Как " + ИмяРеквизита
			+ "РеквизитСсылка,ПредставлениеСсылки(" + ИмяРеквизита + ") Как " + ИмяРеквизита + "РеквизитПредставление";
		ЗаполнитьЗначенияСвойств(ИнформацияОМетаданных.Добавить(),
			Новый Структура("ТипМетаданныхВИминительномПадеже, ТипМетаданныхВТворительномПадеже, ИмяМетаданных", "Реквизит", НСтр("ru = 'реквизите'"), ИмяРеквизита));
	КонецЦикла;
	
	Если ОбъектМетаданных.РежимЗаписи = Метаданные.СвойстваОбъектов.РежимЗаписиРегистра.ПодчинениеРегистратору Тогда
		НайтиБитыеСсылкиВПодчиненныхРегистрахСведений(ОбъектМетаданных, ПоляВыборки, ИнформацияОМетаданных, ПараметрыПроверки);
	Иначе
		Если ОбъектМетаданных.ПериодичностьРегистраСведений <> Метаданные.СвойстваОбъектов.ПериодичностьРегистраСведений.Непериодический Тогда
			НайтиБитыеСсылкиВНеПодчиненныхПериодическихРегистрахСведений(ОбъектМетаданных, ПоляВыборки, ИнформацияОМетаданных, ПараметрыПроверки);
		Иначе
			НайтиБитыеСсылкиВНеПодчиненныхНеПериодическихРегистрахСведений(ОбъектМетаданных, ПоляВыборки, ИнформацияОМетаданных, ПараметрыПроверки);
		КонецЕсли;
	КонецЕсли;
	
КонецПроцедуры

Процедура НайтиБитыеСсылкиВПодчиненныхРегистрахСведений(ОбъектМетаданных, ПоляВыборки, ИнформацияОМетаданных, ПараметрыПроверки)
	
	ПоляВыборки = ПоляВыборки + ", НомерСтроки Как НомерСтроки, Регистратор Как РегистраторРеквизитСсылка, ПредставлениеСсылки(Регистратор) Как РегистраторРеквизитПредставление";
	ЗаполнитьЗначенияСвойств(ИнформацияОМетаданных.Добавить(),
		Новый Структура("ТипМетаданныхВИминительномПадеже, ТипМетаданныхВТворительномПадеже, ИмяМетаданных", "Реквизит", НСтр("ru = 'реквизите'"), "Регистратор"));
			
			
	Запрос = Новый Запрос(
	"ВЫБРАТЬ ПЕРВЫЕ 1000
	|	&ПоляВыборки КАК ПоляВыборки
	|ИЗ
	|	&ОбъектМетаданных КАК ОбъектМетаданных
	|ГДЕ
	|	ВЫБОР
	|			КОГДА ОбъектМетаданных.Регистратор = &Регистратор
	|				ТОГДА ОбъектМетаданных.НомерСтроки > &НомерСтроки
	|			ИНАЧЕ ОбъектМетаданных.Регистратор > &Регистратор
	|		КОНЕЦ
	|	И &Периодичность
	|
	|УПОРЯДОЧИТЬ ПО
	|	ОбъектМетаданных.Регистратор,
	|	ОбъектМетаданных.НомерСтроки");
	
	Запрос.Текст = СтрЗаменить(Запрос.Текст, "КАК ПоляВыборки", "");
	Запрос.Текст = СтрЗаменить(Запрос.Текст, "&ОбъектМетаданных", ОбъектМетаданных.ПолноеИмя());
	Запрос.Текст = СтрЗаменить(Запрос.Текст, "&ПоляВыборки", ПоляВыборки);
	
	Запрос.УстановитьПараметр("НомерСтроки", 0);
	Запрос.УстановитьПараметр("Регистратор", "");
	
	Если ОбъектМетаданных.ПериодичностьРегистраСведений = Метаданные.СвойстваОбъектов.ПериодичностьРегистраСведений.Непериодический Тогда
		Запрос.Текст = СтрЗаменить(Запрос.Текст, "&Периодичность", "Истина");
	Иначе
		Запрос.Текст = СтрЗаменить(Запрос.Текст, "&Периодичность", "ОбъектМетаданных.Период > &ДатаНачалаПроверки");
		Запрос.УстановитьПараметр("ДатаНачалаПроверки", ПараметрыПроверки.ДатаНачалаПроверки);
	КонецЕсли;
	
	Результат = Запрос.Выполнить().Выгрузить();
	
	КэшБитыхСсылок = Новый Массив;
	Пока Истина Цикл
		
		Если Результат.Количество() = 0 Тогда
			Прервать;
		КонецЕсли;
		
		Для Каждого СтрокаРезультата Из Результат Цикл
			
			Для Каждого ПодчиненныйОбъект Из ИнформацияОМетаданных Цикл
				
				ТекущаяСсылка     = СтрокаРезультата[ПодчиненныйОбъект.ИмяМетаданных + ПодчиненныйОбъект.ТипМетаданныхВИминительномПадеже + "Ссылка"];
				УточнениеПроблемы = "";
				
				Если Не ОбщегоНазначения.ЗначениеСсылочногоТипа(ТекущаяСсылка) Или Не ЗначениеЗаполнено(ТекущаяСсылка) Тогда
					Продолжить;
				КонецЕсли;
				
				Если КэшБитыхСсылок.Найти(ТекущаяСсылка) <> Неопределено Тогда
					
					УточнениеПроблемы = УточнениеПроблемы + ?(ЗначениеЗаполнено(УточнениеПроблемы), Символы.ПС, "")
						+ СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(НСтр("ru='У регистра сведений ""%1"" в %2, записи №%3 по регистратору ""%4"" указан несуществующий элемент: ""%5"".'"),
							ОбъектМетаданных.Представление(), ПодчиненныйОбъект.ТипМетаданныхВТворительномПадеже,
							Формат(СтрокаРезультата.НомерСтроки, "ЧГ=0"), СтрокаРезультата["РегистраторРеквизитПредставление"],
							СтрокаРезультата[ПодчиненныйОбъект.ИмяМетаданных + ПодчиненныйОбъект.ТипМетаданныхВИминительномПадеже + "Представление"]);
						
				Иначе
					
					Если Не ОбщегоНазначения.СсылкаСуществует(ТекущаяСсылка) Тогда
						
						УточнениеПроблемы = УточнениеПроблемы + ?(ЗначениеЗаполнено(УточнениеПроблемы), Символы.ПС, "")
							+ СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(НСтр("ru='У регистра сведений ""%1"" в %2, записи №%3 по регистратору ""%4"" указан несуществующий элемент: ""%5"".'"),
								ОбъектМетаданных.Представление(), ПодчиненныйОбъект.ТипМетаданныхВТворительномПадеже,
								Формат(СтрокаРезультата.НомерСтроки, "ЧГ=0"), СтрокаРезультата["РегистраторРеквизитПредставление"],
								СтрокаРезультата[ПодчиненныйОбъект.ИмяМетаданных + ПодчиненныйОбъект.ТипМетаданныхВИминительномПадеже + "Представление"]);
						КэшБитыхСсылок.Добавить(ТекущаяСсылка);
						
					КонецЕсли;
					
				КонецЕсли;
				
				Если Не ЗначениеЗаполнено(УточнениеПроблемы) Тогда
					Продолжить;
				КонецЕсли;
				
				СтруктураНабораЗаписей = Новый Структура;
				СтруктураНабораЗаписей.Вставить("Регистратор", СтрокаРезультата["РегистраторРеквизитСсылка"]);
				
				Проблема = ОписаниеПроблемы(ОбщегоНазначения.ИдентификаторОбъектаМетаданных(ОбъектМетаданных), ПараметрыПроверки);
				Проблема.УточнениеПроблемы        = НСтр("ru = 'Обнаружено нарушение ссылочной целостности:'") + Символы.ПС + УточнениеПроблемы;
				Проблема.ДополнительнаяИнформация = Новый ХранилищеЗначения(СтруктураНабораЗаписей);
				ЗаписатьПроблему(Проблема, ПараметрыПроверки);
				
			КонецЦикла;
			
		КонецЦикла;
		
		Запрос.УстановитьПараметр("НомерСтроки", СтрокаРезультата["НомерСтроки"]);
		Запрос.УстановитьПараметр("Регистратор", СтрокаРезультата["РегистраторРеквизитСсылка"]);
		Результат = Запрос.Выполнить().Выгрузить();
		
	КонецЦикла;
	Запрос = Неопределено;
	
КонецПроцедуры

Процедура НайтиБитыеСсылкиВНеПодчиненныхПериодическихРегистрахСведений(ОбъектМетаданных, ПоляВыборки, ИнформацияОМетаданных, ПараметрыПроверки)
	
	Условие            = "Период >= &Период";
	ПоляУпорядочивания = "Период";
	Измерения          = ОбъектМетаданных.Измерения;
	
	Для Каждого Измерение Из Измерения Цикл
		Условие            = Условие + ?(ЗначениеЗаполнено(Условие), " И ", "") + Измерение.Имя + " >= &" + Измерение.Имя;
		ПоляУпорядочивания = ПоляУпорядочивания + ?(ЗначениеЗаполнено(ПоляУпорядочивания), ", ", "") + Измерение.Имя;
	КонецЦикла;
	
	ТекстЗапроса =
	"ВЫБРАТЬ ПЕРВЫЕ 1000
	|	ОбъектМетаданных.Период КАК Период,
	|	&ПоляВыборки КАК ПоляВыборки
	|ИЗ
	|	&ОбъектМетаданных КАК ОбъектМетаданных
	|ГДЕ
	|	ОбъектМетаданных.Период > &ДатаНачалаПроверки
	|	И &Условие";
	
	ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "&Условие",          "Истина И Истина И Истина Упорядочить По " + ПоляУпорядочивания);
	ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "КАК ПоляВыборки",   "");
	ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "&ОбъектМетаданных", ОбъектМетаданных.ПолноеИмя());
	ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "&ПоляВыборки",      ПоляВыборки);
	
	Запрос = Новый Запрос(ТекстЗапроса);
	Запрос.УстановитьПараметр("ДатаНачалаПроверки", ПараметрыПроверки.ДатаНачалаПроверки);
	Результат = Запрос.Выполнить().Выгрузить();
	
	УсловиеАбсолюта = "Истина И Истина И Истина";
	КэшБитыхСсылок  = Новый Массив;
	
	Пока Истина Цикл
		
		ЭтоПервыйПроход = СтрНайти(Запрос.Текст, УсловиеАбсолюта) <> 0;
		
		Если Результат.Количество() = 0 Или (Не ЭтоПервыйПроход И Результат.Количество() = 1) Тогда
			Прервать;
		КонецЕсли;
		
		Для Каждого СтрокаРезультата Из Результат Цикл
			
			Если Не ЭтоПервыйПроход И Результат.Индекс(СтрокаРезультата) = 0 Тогда
				Продолжить;
			КонецЕсли;
			
			Для Каждого ПодчиненныйОбъект Из ИнформацияОМетаданных Цикл
				
				ТекущаяСсылка     = СтрокаРезультата[ПодчиненныйОбъект.ИмяМетаданных + ПодчиненныйОбъект.ТипМетаданныхВИминительномПадеже + "Ссылка"];
				УточнениеПроблемы = "";
				
				Если Не ОбщегоНазначения.ЗначениеСсылочногоТипа(ТекущаяСсылка) Или Не ЗначениеЗаполнено(ТекущаяСсылка) Тогда
					Продолжить;
				КонецЕсли;
				
				Если КэшБитыхСсылок.Найти(ТекущаяСсылка) <> Неопределено Тогда
					
					УточнениеПроблемы = УточнениеПроблемы + ?(ЗначениеЗаполнено(УточнениеПроблемы), Символы.ПС, "")
						+ СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(НСтр("ru='У регистра сведений ""%1"" в %2, по комбинации измерений ""%3"" указан несуществующий элемент: ""%4"".'"),
							ОбъектМетаданных.Представление(), ПодчиненныйОбъект.ТипМетаданныхВТворительномПадеже,
							ПоляУпорядочивания, СтрокаРезультата[ПодчиненныйОбъект.ИмяМетаданных + ПодчиненныйОбъект.ТипМетаданныхВИминительномПадеже + "Представление"]);
					
				Иначе
					
					Если Не ОбщегоНазначения.СсылкаСуществует(ТекущаяСсылка) Тогда
						
						УточнениеПроблемы = УточнениеПроблемы + ?(ЗначениеЗаполнено(УточнениеПроблемы), Символы.ПС, "")
							+ СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(НСтр("ru='У регистра сведений ""%1"" в %2, по комбинации измерений ""%3"" указан несуществующий элемент: ""%4"".'"),
								ОбъектМетаданных.Представление(), ПодчиненныйОбъект.ТипМетаданныхВТворительномПадеже,
								ПоляУпорядочивания, СтрокаРезультата[ПодчиненныйОбъект.ИмяМетаданных + ПодчиненныйОбъект.ТипМетаданныхВИминительномПадеже + "Представление"]);
						КэшБитыхСсылок.Добавить(ТекущаяСсылка);
						
					КонецЕсли;
					
				КонецЕсли;
				
				Если Не ЗначениеЗаполнено(УточнениеПроблемы) Тогда
					Продолжить;
				КонецЕсли;
				
				СтруктураНабораЗаписей = Новый Структура;
				СтруктураНабораЗаписей.Вставить("Период", СтрокаРезультата["Период"]);
				Для Каждого Измерение Из Измерения Цикл
					ИзмерениеСсылка = СтрокаРезультата[Измерение.Имя + "ИзмерениеСсылка"];
					Если КэшБитыхСсылок.Найти(ИзмерениеСсылка) <> Неопределено Тогда
						Продолжить;
					КонецЕсли;
					СтруктураНабораЗаписей.Вставить(Измерение.Имя, ИзмерениеСсылка);
				КонецЦикла;
				
				Проблема = ОписаниеПроблемы(ОбщегоНазначения.ИдентификаторОбъектаМетаданных(ОбъектМетаданных), ПараметрыПроверки);
				Проблема.УточнениеПроблемы        = НСтр("ru = 'Обнаружено нарушение ссылочной целостности:'") + Символы.ПС + УточнениеПроблемы;
				Проблема.ДополнительнаяИнформация = Новый ХранилищеЗначения(СтруктураНабораЗаписей);
				ЗаписатьПроблему(Проблема, ПараметрыПроверки);
				
			КонецЦикла;
			
		КонецЦикла;
		
		Если ЭтоПервыйПроход Тогда
			Запрос.Текст = СтрЗаменить(Запрос.Текст, УсловиеАбсолюта, Условие);
		КонецЕсли;
		
		Запрос.УстановитьПараметр("Период", СтрокаРезультата["Период"]);
		Для Каждого Измерение Из Измерения Цикл
			Запрос.УстановитьПараметр(Измерение.Имя, СтрокаРезультата[Измерение.Имя + "ИзмерениеСсылка"]);
		КонецЦикла;
		
		Результат = Запрос.Выполнить().Выгрузить();
		
	КонецЦикла;
	Запрос = Неопределено;
	
КонецПроцедуры

Процедура НайтиБитыеСсылкиВНеПодчиненныхНеПериодическихРегистрахСведений(ОбъектМетаданных, ПоляВыборки, ИнформацияОМетаданных, ПараметрыПроверки)
	
	Условие            = "";
	ПоляУпорядочивания = "";
	Измерения          = ОбъектМетаданных.Измерения;
	
	Для Каждого Измерение Из Измерения Цикл
		Условие            = Условие + ?(ЗначениеЗаполнено(Условие), " И ", "") + Измерение.Имя + " >= &" + Измерение.Имя;
		ПоляУпорядочивания = ПоляУпорядочивания + ?(ЗначениеЗаполнено(ПоляУпорядочивания), ", ", "") + Измерение.Имя;
	КонецЦикла;
	
	ТекстЗапроса =
	"ВЫБРАТЬ ПЕРВЫЕ 1000
	|	&ПоляВыборки КАК ПоляВыборки
	|ИЗ
	|	&ОбъектМетаданных КАК ОбъектМетаданных
	|ГДЕ
	|	&Условие";
	
	ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "&Условие",          "ИСТИНА УПОРЯДОЧИТЬ ПО " + ПоляУпорядочивания);
	ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "КАК ПоляВыборки",   "");
	ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "&ОбъектМетаданных", ОбъектМетаданных.ПолноеИмя());
	ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "&ПоляВыборки",      ПоляВыборки);
	
	Запрос    = Новый Запрос(ТекстЗапроса);
	Результат = Запрос.Выполнить().Выгрузить();
	
	УсловиеАбсолюта = "ГДЕ" + Символы.ПС + Символы.Таб + "ИСТИНА";
	КэшБитыхСсылок  = Новый Массив;
	
	Пока Истина Цикл
		
		ЭтоПервыйПроход = СтрНайти(Запрос.Текст, УсловиеАбсолюта) <> 0;
		
		Если Результат.Количество() = 0 Или (Не ЭтоПервыйПроход И Результат.Количество() = 1) Тогда
			Прервать;
		КонецЕсли;
		
		Для Каждого СтрокаРезультата Из Результат Цикл
			
			Если Не ЭтоПервыйПроход И Результат.Индекс(СтрокаРезультата) = 0 Тогда
				Продолжить;
			КонецЕсли;
			
			Для Каждого ПодчиненныйОбъект Из ИнформацияОМетаданных Цикл
				
				ТекущаяСсылка     = СтрокаРезультата[ПодчиненныйОбъект.ИмяМетаданных + ПодчиненныйОбъект.ТипМетаданныхВИминительномПадеже + "Ссылка"];
				УточнениеПроблемы = "";
				
				Если Не ОбщегоНазначения.ЗначениеСсылочногоТипа(ТекущаяСсылка) Или Не ЗначениеЗаполнено(ТекущаяСсылка) Тогда
					Продолжить;
				КонецЕсли;
				
				Если КэшБитыхСсылок.Найти(ТекущаяСсылка) <> Неопределено Тогда
					
					УточнениеПроблемы = УточнениеПроблемы + ?(ЗначениеЗаполнено(УточнениеПроблемы), Символы.ПС, "")
						+ СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(НСтр("ru='У регистра сведений ""%1"" в %2, по комбинации измерений ""%3"" указан несуществующий элемент: ""%4"".'"),
							ОбъектМетаданных.Представление(), ПодчиненныйОбъект.ТипМетаданныхВТворительномПадеже,
							ПоляУпорядочивания, СтрокаРезультата[ПодчиненныйОбъект.ИмяМетаданных + ПодчиненныйОбъект.ТипМетаданныхВИминительномПадеже + "Представление"]);
						
				Иначе
					
					Если Не ОбщегоНазначения.СсылкаСуществует(ТекущаяСсылка) Тогда
						
						УточнениеПроблемы = УточнениеПроблемы + ?(ЗначениеЗаполнено(УточнениеПроблемы), Символы.ПС, "")
							+ СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(НСтр("ru='У регистра сведений ""%1"" в %2, по комбинации измерений ""%3"" указан несуществующий элемент: ""%4"".'"),
								ОбъектМетаданных.Представление(), ПодчиненныйОбъект.ТипМетаданныхВТворительномПадеже,
								ПоляУпорядочивания, СтрокаРезультата[ПодчиненныйОбъект.ИмяМетаданных + ПодчиненныйОбъект.ТипМетаданныхВИминительномПадеже + "Представление"]);
						КэшБитыхСсылок.Добавить(ТекущаяСсылка);
						
					КонецЕсли;
					
				КонецЕсли;
				
				Если Не ЗначениеЗаполнено(УточнениеПроблемы) Тогда
					Продолжить;
				КонецЕсли;
				
				СтруктураНабораЗаписей = Новый Структура;
				Для Каждого Измерение Из Измерения Цикл
					ИзмерениеСсылка = СтрокаРезультата[Измерение.Имя + "ИзмерениеСсылка"];
					Если КэшБитыхСсылок.Найти(ИзмерениеСсылка) <> Неопределено Тогда
						Продолжить;
					КонецЕсли;
					СтруктураНабораЗаписей.Вставить(Измерение.Имя, ИзмерениеСсылка);
				КонецЦикла;
				
				Проблема = ОписаниеПроблемы(ОбщегоНазначения.ИдентификаторОбъектаМетаданных(ОбъектМетаданных), ПараметрыПроверки);
				Проблема.УточнениеПроблемы        = НСтр("ru = 'Обнаружено нарушение ссылочной целостности:'") + Символы.ПС + УточнениеПроблемы;
				Проблема.ДополнительнаяИнформация = Новый ХранилищеЗначения(СтруктураНабораЗаписей);
				ЗаписатьПроблему(Проблема, ПараметрыПроверки);
				
			КонецЦикла;
			
		КонецЦикла;
		
		Если ЭтоПервыйПроход Тогда
			Запрос.Текст = СтрЗаменить(Запрос.Текст, УсловиеАбсолюта, "Где " + Условие);
		КонецЕсли;
		
		Для Каждого Измерение Из Измерения Цикл
			Запрос.УстановитьПараметр(Измерение.Имя, СтрокаРезультата[Измерение.Имя + "ИзмерениеСсылка"]);
		КонецЦикла;
		
		Результат = Запрос.Выполнить().Выгрузить();
		
	КонецЦикла;
	Запрос = Неопределено;
	
КонецПроцедуры

#КонецОбласти

#Область КонтрольСсылочнойЦелостностиВРегистрахБухгалтерии

Процедура НайтиБитыеСсылкиВРегистрахБухгалтерии(ОбъектМетаданных, ПараметрыПроверки)
	
	ПолноеИмя            = ОбъектМетаданных.ПолноеИмя();
	Измерения            = ОбъектМетаданных.Измерения;
	Реквизиты            = ОбъектМетаданных.Реквизиты;
	СтандартныеРеквизиты = ОбъектМетаданных.СтандартныеРеквизиты;
	
	МаксимальноеКоличествоСубконто = ОбъектМетаданных.ПланСчетов.МаксКоличествоСубконто;
	КорреспонденцияОбъекта         = ОбъектМетаданных.Корреспонденция;
	
	ИнформацияОМетаданных = Новый ТаблицаЗначений;
	ИнформацияОМетаданных.Колонки.Добавить("ТипМетаданныхВИминительномПадеже", Новый ОписаниеТипов("Строка", , , , Новый КвалификаторыСтроки(64)));
	ИнформацияОМетаданных.Колонки.Добавить("ТипМетаданныхВТворительномПадеже", Новый ОписаниеТипов("Строка", , , , Новый КвалификаторыСтроки(64)));
	ИнформацияОМетаданных.Колонки.Добавить("ИмяМетаданных", Новый ОписаниеТипов("Строка", , , , Новый КвалификаторыСтроки(128)));
	
	ПоляВыборки = "НомерСтроки Как НомерСтроки, Регистратор Как РегистраторРеквизитСсылка, ПредставлениеСсылки(Регистратор) Как РегистраторРеквизитПредставление";
	ЗаполнитьЗначенияСвойств(ИнформацияОМетаданных.Добавить(),
		Новый Структура("ТипМетаданныхВИминительномПадеже, ТипМетаданныхВТворительномПадеже, ИмяМетаданных", "Реквизит", НСтр("ru = 'реквизите'"), "Регистратор"));
		
		
	Для ИндексСубконто = 1 По МаксимальноеКоличествоСубконто Цикл
	
		Если КорреспонденцияОбъекта Тогда
	
			ИндексСтрокой = Формат(ИндексСубконто, "ЧГ=0");
			
			ИмяСубконтоДт = "СубконтоДт" + ИндексСтрокой;
			ПоляВыборки = ПоляВыборки + "," + ИмяСубконтоДт + " Как " + ИмяСубконтоДт
				+ "СубконтоДтСсылка,ПредставлениеСсылки(" + ИмяСубконтоДт + ") Как " + ИмяСубконтоДт + "СубконтоДтПредставление";
			ЗаполнитьЗначенияСвойств(ИнформацияОМетаданных.Добавить(),
				Новый Структура("ТипМетаданныхВИминительномПадеже, ТипМетаданныхВТворительномПадеже, ИмяМетаданных", "СубконтоДт",
				СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(НСтр("ru = 'субконто дт %1'"), ИндексСтрокой), ИмяСубконтоДт));
				
			ИмяСубконтоКт = "СубконтоКт" + ИндексСтрокой;
			ПоляВыборки = ПоляВыборки + "," + ИмяСубконтоКт + " Как " + ИмяСубконтоКт
				+ "СубконтоКтСсылка,ПредставлениеСсылки(" + ИмяСубконтоКт + ") Как " + ИмяСубконтоКт + "СубконтоКтПредставление";
			ЗаполнитьЗначенияСвойств(ИнформацияОМетаданных.Добавить(),
				Новый Структура("ТипМетаданныхВИминительномПадеже, ТипМетаданныхВТворительномПадеже, ИмяМетаданных", "СубконтоКт",
				СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(НСтр("ru = 'субконто кт %1'"), ИндексСтрокой), ИмяСубконтоКт));
				
			ИмяВидаСубконтоДт = "ВидСубконтоДт" + ИндексСтрокой;
			ПоляВыборки = ПоляВыборки + "," + ИмяВидаСубконтоДт + " Как " + ИмяВидаСубконтоДт
				+ "ВидСубконтоДтСсылка,ПредставлениеСсылки(" + ИмяВидаСубконтоДт + ") Как " + ИмяВидаСубконтоДт + "ВидСубконтоДтПредставление";
			ЗаполнитьЗначенияСвойств(ИнформацияОМетаданных.Добавить(),
				Новый Структура("ТипМетаданныхВИминительномПадеже, ТипМетаданныхВТворительномПадеже, ИмяМетаданных", "ВидСубконтоДт",
				СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(НСтр("ru = 'виде субконто дт %1'"), ИндексСтрокой), ИмяВидаСубконтоДт));
				
			ИмяВидаСубконтоКт = "ВидСубконтоКт" + ИндексСтрокой;
			ПоляВыборки = ПоляВыборки + "," + ИмяВидаСубконтоКт + " Как " + ИмяВидаСубконтоКт
				+ "ВидСубконтоКтСсылка,ПредставлениеСсылки(" + ИмяВидаСубконтоКт + ") Как " + ИмяВидаСубконтоКт + "ВидСубконтоКтПредставление";
			ЗаполнитьЗначенияСвойств(ИнформацияОМетаданных.Добавить(),
				Новый Структура("ТипМетаданныхВИминительномПадеже, ТипМетаданныхВТворительномПадеже, ИмяМетаданных", "ВидСубконтоКт",
				СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(НСтр("ru = 'виде субконто кт %1'"), ИндексСтрокой), ИмяВидаСубконтоКт));
	
		Иначе
	
			ИмяСубконто = "Субконто" + ИндексСтрокой;
			ПоляВыборки = ПоляВыборки + "," + ИмяСубконто + " Как " + ИмяСубконто
				+ "СубконтоСсылка,ПредставлениеСсылки(" + ИмяСубконто + ") Как " + ИмяСубконто + "СубконтоПредставление";
			ЗаполнитьЗначенияСвойств(ИнформацияОМетаданных.Добавить(),
				Новый Структура("ТипМетаданныхВИминительномПадеже, ТипМетаданныхВТворительномПадеже, ИмяМетаданных", "Субконто",
				СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(НСтр("ru = 'субконто %1'"), ИндексСтрокой), ИмяСубконто));
				
			ИмяВидаСубконто = "ВидСубконто" + ИндексСтрокой;
			ПоляВыборки = ПоляВыборки + "," + ИмяВидаСубконто + " Как " + ИмяВидаСубконто
				+ "ВидСубконтоСсылка,ПредставлениеСсылки(" + ИмяВидаСубконто + ") Как " + ИмяВидаСубконто + "ВидСубконтоПредставление";
			ЗаполнитьЗначенияСвойств(ИнформацияОМетаданных.Добавить(),
				Новый Структура("ТипМетаданныхВИминительномПадеже, ТипМетаданныхВТворительномПадеже, ИмяМетаданных", "ВидСубконто",
				СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(НСтр("ru = 'виде субконто %1'"), ИндексСтрокой), ИмяВидаСубконто));
	
		КонецЕсли;
		
	КонецЦикла;
	
	Если КорреспонденцияОбъекта Тогда
		
		ИмяСчетаДт = "СчетДт";
		ПоляВыборки = ПоляВыборки + "," + ИмяСчетаДт + " Как " + ИмяСчетаДт
			+ "СчетДтСсылка,ПредставлениеСсылки(" + ИмяСчетаДт + ") Как " + ИмяСчетаДт + "СчетДтПредставление";
		ЗаполнитьЗначенияСвойств(ИнформацияОМетаданных.Добавить(),
			Новый Структура("ТипМетаданныхВИминительномПадеже, ТипМетаданныхВТворительномПадеже, ИмяМетаданных", "СчетДт",
			НСтр("ru = 'счете дт'"), ИмяСчетаДт));
			
		ИмяСчетаКт = "СчетКт";
		ПоляВыборки = ПоляВыборки + "," + ИмяСчетаКт + " Как " + ИмяСчетаКт
			+ "СчетКтСсылка,ПредставлениеСсылки(" + ИмяСчетаКт + ") Как " + ИмяСчетаКт + "СчетКтПредставление";
		ЗаполнитьЗначенияСвойств(ИнформацияОМетаданных.Добавить(),
			Новый Структура("ТипМетаданныхВИминительномПадеже, ТипМетаданныхВТворительномПадеже, ИмяМетаданных", "СчетКт",
			НСтр("ru = 'счете кт'"), ИмяСчетаКт));
		
	Иначе
		
		ИмяСчета = "Счет";
		ПоляВыборки = ПоляВыборки + "," + ИмяСчета + " Как " + ИмяСчета
			+ "ИмяСчетаСсылка,ПредставлениеСсылки(" + ИмяСчета + ") Как " + ИмяСчета + "ИмяСчетаПредставление";
		ЗаполнитьЗначенияСвойств(ИнформацияОМетаданных.Добавить(),
			Новый Структура("ТипМетаданныхВИминительномПадеже, ТипМетаданныхВТворительномПадеже, ИмяМетаданных", "Счет",
			НСтр("ru = 'счете'"), ИмяСчета));
		
	КонецЕсли;
		
	Для Каждого Измерение Из Измерения Цикл
		
		Если Не (Измерение.Балансовый Или Не КорреспонденцияОбъекта) Тогда
			
			ИмяИзмеренияДт = Измерение.Имя + "Дт";
			ПоляВыборки = ПоляВыборки + "," + ИмяИзмеренияДт + " Как " + ИмяИзмеренияДт
				+ "ИзмерениеДтСсылка,ПредставлениеСсылки(" + ИмяИзмеренияДт + ") Как " + ИмяИзмеренияДт + "ИзмерениеДтПредставление";
			ЗаполнитьЗначенияСвойств(ИнформацияОМетаданных.Добавить(),
				Новый Структура("ТипМетаданныхВИминительномПадеже, ТипМетаданныхВТворительномПадеже, ИмяМетаданных", "ИзмерениеДт", НСтр("ru = 'измерении дт'"), ИмяИзмеренияДт));
				
			ИмяИзмеренияКт = Измерение.Имя + "Кт";
			ПоляВыборки = ПоляВыборки + "," + ИмяИзмеренияКт + " Как " + ИмяИзмеренияКт
				+ "ИзмерениеКтСсылка,ПредставлениеСсылки(" + ИмяИзмеренияКт + ") Как " + ИмяИзмеренияКт + "ИзмерениеКтПредставление";
			ЗаполнитьЗначенияСвойств(ИнформацияОМетаданных.Добавить(),
				Новый Структура("ТипМетаданныхВИминительномПадеже, ТипМетаданныхВТворительномПадеже, ИмяМетаданных", "ИзмерениеКт", НСтр("ru = 'измерении кт'"), ИмяИзмеренияКт));
				
		Иначе
				
			ИмяИзмерения = Измерение.Имя;
			ПоляВыборки = ПоляВыборки + "," + ИмяИзмерения + " Как " + ИмяИзмерения
				+ "ИзмерениеСсылка,ПредставлениеСсылки(" + ИмяИзмерения + ") Как " + ИмяИзмерения + "ИзмерениеПредставление";
			ЗаполнитьЗначенияСвойств(ИнформацияОМетаданных.Добавить(),
				Новый Структура("ТипМетаданныхВИминительномПадеже, ТипМетаданныхВТворительномПадеже, ИмяМетаданных", "Измерение", НСтр("ru = 'измерении'"), ИмяИзмерения));
			
		КонецЕсли;
		
	КонецЦикла;
	
	Для Каждого Реквизит Из Реквизиты Цикл
		ИмяРеквизита = Реквизит.Имя;
		ПоляВыборки = ПоляВыборки + "," + ИмяРеквизита + " Как " + ИмяРеквизита
			+ "РеквизитСсылка,ПредставлениеСсылки(" + ИмяРеквизита + ") Как " + ИмяРеквизита + "РеквизитПредставление";
		ЗаполнитьЗначенияСвойств(ИнформацияОМетаданных.Добавить(),
			Новый Структура("ТипМетаданныхВИминительномПадеже, ТипМетаданныхВТворительномПадеже, ИмяМетаданных", "Реквизит", НСтр("ru = 'реквизите'"), ИмяРеквизита));
		КонецЦикла;
		
	Для Каждого СтандартныйРеквизит Из СтандартныеРеквизиты Цикл
			
		ИмяСтандартногоРеквизита = СтандартныйРеквизит.Имя;
		Если ИмяСтандартногоРеквизита = "Регистратор" Или ИмяСтандартногоРеквизита = "НомерСтроки" Или СтрНайти(ИмяСтандартногоРеквизита, "Субконто") <> 0 Тогда
			Продолжить;
		КонецЕсли;
		
		ПоляВыборки = ПоляВыборки + "," + ИмяСтандартногоРеквизита + " Как " + ИмяСтандартногоРеквизита
			+ "СтандартныйРеквизитСсылка,ПредставлениеСсылки(" + ИмяСтандартногоРеквизита + ") Как " + ИмяСтандартногоРеквизита + "СтандартныйРеквизитПредставление";
		ЗаполнитьЗначенияСвойств(ИнформацияОМетаданных.Добавить(),
			Новый Структура("ТипМетаданныхВИминительномПадеже, ТипМетаданныхВТворительномПадеже, ИмяМетаданных", "СтандартныйРеквизит", НСтр("ru = 'стандартном реквизите'"), ИмяСтандартногоРеквизита));
			
	КонецЦикла;
	
	Запрос = Новый Запрос(
	"ВЫБРАТЬ ПЕРВЫЕ 1000
	|	&ПоляВыборки КАК ПоляВыборки
	|ИЗ
	|	&ОбъектМетаданных КАК ОбъектМетаданных
	|
	|УПОРЯДОЧИТЬ ПО
	|	ОбъектМетаданных.Регистратор,
	|	ОбъектМетаданных.НомерСтроки");
	
	Условие =
	"Период > &ДатаНачалаПроверки
	|И ВЫБОР
	|		КОГДА Регистратор = &Регистратор
	|				ТОГДА НомерСтроки > &НомерСтроки
	|			ИНАЧЕ Регистратор > &Регистратор
	|		КОНЕЦ";
	
	
	Запрос.Текст = СтрЗаменить(Запрос.Текст, "КАК ПоляВыборки", "");
	Запрос.Текст = СтрЗаменить(Запрос.Текст, "&ОбъектМетаданных", ОбъектМетаданных.ПолноеИмя() + ".ДвиженияССубконто(, , " + Условие + ", , )");
	Запрос.Текст = СтрЗаменить(Запрос.Текст, "&ПоляВыборки", ПоляВыборки);
	
	Запрос.УстановитьПараметр("ДатаНачалаПроверки", ПараметрыПроверки.ДатаНачалаПроверки);
	Запрос.УстановитьПараметр("НомерСтроки",        0);
	Запрос.УстановитьПараметр("Регистратор",        "");
	
	Результат = Запрос.Выполнить().Выгрузить();
	
	КэшБитыхСсылок = Новый Массив;
	Пока Истина Цикл
		
		Если Результат.Количество() = 0 Тогда
			Прервать;
		КонецЕсли;
		
		Для Каждого СтрокаРезультата Из Результат Цикл
			
			Для Каждого ПодчиненныйОбъект Из ИнформацияОМетаданных Цикл
				
				ТекущаяСсылка     = СтрокаРезультата[ПодчиненныйОбъект.ИмяМетаданных + ПодчиненныйОбъект.ТипМетаданныхВИминительномПадеже + "Ссылка"];
				УточнениеПроблемы = "";
				
				Если Не ОбщегоНазначения.ЗначениеСсылочногоТипа(ТекущаяСсылка) Или Не ЗначениеЗаполнено(ТекущаяСсылка) Тогда
					Продолжить;
				КонецЕсли;
				
				Если КэшБитыхСсылок.Найти(ТекущаяСсылка) <> Неопределено Тогда
					
					УточнениеПроблемы = УточнениеПроблемы + ?(ЗначениеЗаполнено(УточнениеПроблемы), Символы.ПС, "")
						+ СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(НСтр("ru='У регистра бухгалтерии ""%1"" в %2, записи №%3 по регистратору ""%4"" указан несуществующий элемент: ""%5"".'"),
							ОбъектМетаданных.Представление(), ПодчиненныйОбъект.ТипМетаданныхВТворительномПадеже,
							Формат(СтрокаРезультата.НомерСтроки, "ЧГ=0"), СтрокаРезультата["РегистраторРеквизитПредставление"],
							СтрокаРезультата[ПодчиненныйОбъект.ИмяМетаданных + ПодчиненныйОбъект.ТипМетаданныхВИминительномПадеже + "Представление"]);
					
				Иначе
					
					Если Не ОбщегоНазначения.СсылкаСуществует(ТекущаяСсылка) Тогда
						
						УточнениеПроблемы = УточнениеПроблемы + ?(ЗначениеЗаполнено(УточнениеПроблемы), Символы.ПС, "")
							+ СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(НСтр("ru='У регистра бухгалтерии ""%1"" в %2, записи №%3 по регистратору ""%4"" указан несуществующий элемент: ""%5"".'"),
								ОбъектМетаданных.Представление(), ПодчиненныйОбъект.ТипМетаданныхВТворительномПадеже,
								Формат(СтрокаРезультата.НомерСтроки, "ЧГ=0"), СтрокаРезультата["РегистраторРеквизитПредставление"],
								СтрокаРезультата[ПодчиненныйОбъект.ИмяМетаданных + ПодчиненныйОбъект.ТипМетаданныхВИминительномПадеже + "Представление"]);
						КэшБитыхСсылок.Добавить(ТекущаяСсылка);
						
					КонецЕсли;
					
				КонецЕсли;
				
				Если Не ЗначениеЗаполнено(УточнениеПроблемы) Тогда
					Продолжить;
				КонецЕсли;
				
				СтруктураНабораЗаписей = Новый Структура;
				СтруктураНабораЗаписей.Вставить("Регистратор", СтрокаРезультата["РегистраторРеквизитСсылка"]);
				
				Проблема = ОписаниеПроблемы(ОбщегоНазначения.ИдентификаторОбъектаМетаданных(ОбъектМетаданных), ПараметрыПроверки);
				Проблема.УточнениеПроблемы        = НСтр("ru = 'Обнаружено нарушение ссылочной целостности:'") + Символы.ПС + УточнениеПроблемы;
				Проблема.ДополнительнаяИнформация = Новый ХранилищеЗначения(СтруктураНабораЗаписей);
				ЗаписатьПроблему(Проблема, ПараметрыПроверки);
				
			КонецЦикла;
			
		КонецЦикла;
		
		Запрос.УстановитьПараметр("НомерСтроки", СтрокаРезультата["НомерСтроки"]);
		Запрос.УстановитьПараметр("Регистратор", СтрокаРезультата["РегистраторРеквизитСсылка"]);
		Результат = Запрос.Выполнить().Выгрузить();
		
	КонецЦикла;
	Запрос = Неопределено;
	
КонецПроцедуры

#КонецОбласти

#Область КонтрольСсылочнойЦелостностиВРегистрахРасчета

Процедура НайтиБитыеСсылкиВРегистрахРасчета(ОбъектМетаданных, ПараметрыПроверки)
	
	ПолноеИмя            = ОбъектМетаданных.ПолноеИмя();
	Измерения            = ОбъектМетаданных.Измерения;
	Реквизиты            = ОбъектМетаданных.Реквизиты;
	СтандартныеРеквизиты = ОбъектМетаданных.СтандартныеРеквизиты;
	
	ИнформацияОМетаданных = Новый ТаблицаЗначений;
	ИнформацияОМетаданных.Колонки.Добавить("ТипМетаданныхВИминительномПадеже", Новый ОписаниеТипов("Строка", , , , Новый КвалификаторыСтроки(64)));
	ИнформацияОМетаданных.Колонки.Добавить("ТипМетаданныхВТворительномПадеже", Новый ОписаниеТипов("Строка", , , , Новый КвалификаторыСтроки(64)));
	ИнформацияОМетаданных.Колонки.Добавить("ИмяМетаданных", Новый ОписаниеТипов("Строка", , , , Новый КвалификаторыСтроки(128)));
	
	ПоляВыборки = "НомерСтроки Как НомерСтроки, Регистратор Как РегистраторРеквизитСсылка, ПредставлениеСсылки(Регистратор) Как РегистраторРеквизитПредставление";
	ЗаполнитьЗначенияСвойств(ИнформацияОМетаданных.Добавить(),
		Новый Структура("ТипМетаданныхВИминительномПадеже, ТипМетаданныхВТворительномПадеже, ИмяМетаданных", "Реквизит", НСтр("ru = 'реквизите'"), "Регистратор"));
	Для Каждого Измерение Из Измерения Цикл
		ИмяИзмерения = Измерение.Имя;
		ПоляВыборки = ПоляВыборки + "," + ИмяИзмерения + " Как " + ИмяИзмерения
			+ "ИзмерениеСсылка,ПредставлениеСсылки(" + ИмяИзмерения + ") Как " + ИмяИзмерения + "ИзмерениеПредставление";
		ЗаполнитьЗначенияСвойств(ИнформацияОМетаданных.Добавить(),
			Новый Структура("ТипМетаданныхВИминительномПадеже, ТипМетаданныхВТворительномПадеже, ИмяМетаданных", "Измерение", НСтр("ru = 'измерении'"), ИмяИзмерения));
	КонецЦикла;
		
	Для Каждого Реквизит Из Реквизиты Цикл
		ИмяРеквизита = Реквизит.Имя;
		ПоляВыборки = ПоляВыборки + "," + ИмяРеквизита + " Как " + ИмяРеквизита
			+ "РеквизитСсылка,ПредставлениеСсылки(" + ИмяРеквизита + ") Как " + ИмяРеквизита + "РеквизитПредставление";
		ЗаполнитьЗначенияСвойств(ИнформацияОМетаданных.Добавить(),
			Новый Структура("ТипМетаданныхВИминительномПадеже, ТипМетаданныхВТворительномПадеже, ИмяМетаданных", "Реквизит", НСтр("ru = 'реквизите'"), ИмяРеквизита));
	КонецЦикла;
		
	Для Каждого СтандартныйРеквизит Из СтандартныеРеквизиты Цикл
		
		ИмяСтандартногоРеквизита = СтандартныйРеквизит.Имя;
		
		Если ИмяСтандартногоРеквизита = "Регистратор" Или ИмяСтандартногоРеквизита = "НомерСтроки" Тогда
			Продолжить;
		КонецЕсли;
		
		ПоляВыборки = ПоляВыборки + "," + ИмяСтандартногоРеквизита + " Как " + ИмяСтандартногоРеквизита
			+ "СтандартныйРеквизитСсылка,ПредставлениеСсылки(" + ИмяСтандартногоРеквизита + ") Как " + ИмяСтандартногоРеквизита + "СтандартныйРеквизитПредставление";
		ЗаполнитьЗначенияСвойств(ИнформацияОМетаданных.Добавить(),
			Новый Структура("ТипМетаданныхВИминительномПадеже, ТипМетаданныхВТворительномПадеже, ИмяМетаданных", "СтандартныйРеквизит", НСтр("ru = 'стандартном реквизите'"), ИмяСтандартногоРеквизита));
			
	КонецЦикла;
	
	ТекстЗапроса =
	"ВЫБРАТЬ ПЕРВЫЕ 1000
	|	&ПоляВыборки КАК ПоляВыборки
	|ИЗ
	|	&ОбъектМетаданных КАК ОбъектМетаданных
	|ГДЕ
	|	ВЫБОР
	|			КОГДА ОбъектМетаданных.Регистратор = &Регистратор
	|				ТОГДА ОбъектМетаданных.НомерСтроки > &НомерСтроки
	|			ИНАЧЕ ОбъектМетаданных.Регистратор > &Регистратор
	|		КОНЕЦ
	|	И ОбъектМетаданных.ПериодРегистрации > &ДатаНачалаПроверки
	|
	|УПОРЯДОЧИТЬ ПО
	|	ОбъектМетаданных.Регистратор,
	|	ОбъектМетаданных.НомерСтроки";
	
	ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "КАК ПоляВыборки", "");
	ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "&ОбъектМетаданных", ПолноеИмя);
	ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "&ПоляВыборки", ПоляВыборки);
	
	Запрос = Новый Запрос(ТекстЗапроса);
	Запрос.УстановитьПараметр("НомерСтроки",        0);
	Запрос.УстановитьПараметр("ДатаНачалаПроверки", ПараметрыПроверки.ДатаНачалаПроверки);
	Запрос.УстановитьПараметр("Регистратор",        "");
	Результат = Запрос.Выполнить().Выгрузить();
	
	КэшБитыхСсылок = Новый Массив;
	Пока Истина Цикл
		
		Если Результат.Количество() = 0 Тогда
			Прервать;
		КонецЕсли;
		
		Для Каждого СтрокаРезультата Из Результат Цикл
			
			Для Каждого ПодчиненныйОбъект Из ИнформацияОМетаданных Цикл
				
				ТекущаяСсылка     = СтрокаРезультата[ПодчиненныйОбъект.ИмяМетаданных + ПодчиненныйОбъект.ТипМетаданныхВИминительномПадеже + "Ссылка"];
				УточнениеПроблемы = "";
				
				Если Не ОбщегоНазначения.ЗначениеСсылочногоТипа(ТекущаяСсылка) Или Не ЗначениеЗаполнено(ТекущаяСсылка) Тогда
					Продолжить;
				КонецЕсли;
				
				Если КэшБитыхСсылок.Найти(ТекущаяСсылка) <> Неопределено Тогда
					
					УточнениеПроблемы = УточнениеПроблемы + ?(ЗначениеЗаполнено(УточнениеПроблемы), Символы.ПС, "")
						+ СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(НСтр("ru='У регистра расчета ""%1"" в %2, записи №%3 по регистратору ""%4"" указан несуществующий элемент: ""%5"".'"),
							ОбъектМетаданных.Представление(), ПодчиненныйОбъект.ТипМетаданныхВТворительномПадеже,
							Формат(СтрокаРезультата.НомерСтроки, "ЧГ=0"), СтрокаРезультата["РегистраторРеквизитПредставление"],
							СтрокаРезультата[ПодчиненныйОбъект.ИмяМетаданных + ПодчиненныйОбъект.ТипМетаданныхВИминительномПадеже + "Представление"]);
					
				Иначе
					
					Если Не ОбщегоНазначения.СсылкаСуществует(ТекущаяСсылка) Тогда
						
						УточнениеПроблемы = УточнениеПроблемы + ?(ЗначениеЗаполнено(УточнениеПроблемы), Символы.ПС, "")
							+ СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(НСтр("ru='У регистра расчета ""%1"" в %2, записи №%3 по регистратору ""%4"" указан несуществующий элемент: ""%5"".'"),
								ОбъектМетаданных.Представление(), ПодчиненныйОбъект.ТипМетаданныхВТворительномПадеже,
								Формат(СтрокаРезультата.НомерСтроки, "ЧГ=0"), СтрокаРезультата["РегистраторРеквизитПредставление"],
								СтрокаРезультата[ПодчиненныйОбъект.ИмяМетаданных + ПодчиненныйОбъект.ТипМетаданныхВИминительномПадеже + "Представление"]);
						КэшБитыхСсылок.Добавить(ТекущаяСсылка);
						
					КонецЕсли;
					
				КонецЕсли;
				
				Если Не ЗначениеЗаполнено(УточнениеПроблемы) Тогда
					Продолжить;
				КонецЕсли;
				
				СтруктураНабораЗаписей = Новый Структура;
				СтруктураНабораЗаписей.Вставить("Регистратор", СтрокаРезультата["РегистраторРеквизитСсылка"]);
				
				Проблема = ОписаниеПроблемы(ОбщегоНазначения.ИдентификаторОбъектаМетаданных(ОбъектМетаданных), ПараметрыПроверки);
				Проблема.УточнениеПроблемы        = НСтр("ru = 'Обнаружено нарушение ссылочной целостности:'") + Символы.ПС + УточнениеПроблемы;
				Проблема.ДополнительнаяИнформация = Новый ХранилищеЗначения(СтруктураНабораЗаписей);
				ЗаписатьПроблему(Проблема, ПараметрыПроверки);
				
			КонецЦикла;
			
		КонецЦикла;
		
		Запрос.УстановитьПараметр("НомерСтроки", СтрокаРезультата["НомерСтроки"]);
		Запрос.УстановитьПараметр("Регистратор", СтрокаРезультата["РегистраторРеквизитСсылка"]);
		Результат = Запрос.Выполнить().Выгрузить();
		
	КонецЦикла;
	Запрос = Неопределено;
	
КонецПроцедуры

#КонецОбласти

#КонецОбласти

#КонецОбласти

#Область ПроверкаЗаполненностиОбязательныхРеквизитов

Процедура НайтиНезаполненныеОбязательныеРеквизиты(ОбъектМетаданных, ПараметрыПроверки)
	
	ПолноеИмя      = ОбъектМетаданных.ПолноеИмя();
	Реквизиты      = ОбъектМетаданных.Реквизиты;
	ТабличныеЧасти = ОбъектМетаданных.ТабличныеЧасти;
	
	ТекстЗапроса = "
	|ВЫБРАТЬ ПЕРВЫЕ 1000
	|	ОбъектМетаданных.Ссылка КАК Ссылка
	|ИЗ
	|	&ОбъектМетаданных КАК ОбъектМетаданных
	|ГДЕ
	|	ОбъектМетаданных.Ссылка > &Ссылка
	|
	|УПОРЯДОЧИТЬ ПО
	|	ОбъектМетаданных.Ссылка";
	
	ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "&ОбъектМетаданных", ПолноеИмя);
	Запрос       = Новый Запрос(ТекстЗапроса);
	Запрос.УстановитьПараметр("Ссылка", "");
	
	Результат = Запрос.Выполнить().Выгрузить();
	
	ОграничениеПоДате = ПараметрыПроверки.ДатаНачалаПроверки;
	Пока Истина Цикл
		
		Если Результат.Количество() = 0 Тогда
			Прервать;
		КонецЕсли;
		
		Для Каждого СтрокаРезультата Из Результат Цикл
			
			СсылкаНаОбъект = СтрокаРезультата.Ссылка;
			
			Если ЗначениеЗаполнено(ОграничениеПоДате)
				И ОбщегоНазначения.ЭтоДокумент(ОбъектМетаданных)
				И ОбщегоНазначения.ЗначениеРеквизитаОбъекта(СсылкаНаОбъект, "Дата") < ОграничениеПоДате Тогда
				Продолжить;
			КонецЕсли;
			
			Если ОбщегоНазначения.ЭтоДокумент(ОбъектМетаданных) И Не ОбщегоНазначения.ЗначениеРеквизитаОбъекта(СсылкаНаОбъект, "Проведен") Тогда
				Продолжить;
			КонецЕсли;
			
			УточнениеПроблемы = "";
			ПроверяемыйОбъект = СсылкаНаОбъект.ПолучитьОбъект();
			Если Не ПроверяемыйОбъект.ПроверитьЗаполнение() Тогда
				УточнениеПроблемы = УточнениеПроблемы(ПолучитьСообщенияПользователю(Истина));
			КонецЕсли;
			
			Если Не ЗначениеЗаполнено(УточнениеПроблемы) Тогда
				Продолжить;
			КонецЕсли;
			
			Проблема = ОписаниеПроблемы(СсылкаНаОбъект, ПараметрыПроверки);
			
			Проблема.УточнениеПроблемы = НСтр("ru = 'Не заполнены реквизиты, обязательные к заполнению:'") + Символы.ПС + УточнениеПроблемы;
			Если Реквизиты.Найти("Ответственный") <> Неопределено Тогда
				Проблема.Вставить("Ответственный", ОбщегоНазначения.ЗначениеРеквизитаОбъекта(СсылкаНаОбъект, "Ответственный"));
			КонецЕсли;
			
			ЗаписатьПроблему(Проблема, ПараметрыПроверки);
			
		КонецЦикла;
		
		Запрос.УстановитьПараметр("Ссылка", СтрокаРезультата.Ссылка);
		Результат = Запрос.Выполнить().Выгрузить();
		
	КонецЦикла;
	Запрос = Неопределено;
	
КонецПроцедуры

#Область ПроверкаЗаполненностиОбязательныхРеквизитовВРегистрах

Процедура НайтиНезаполненныеОбязательныеРеквизитыВРегистрах(ОбъектМетаданных, ПараметрыПроверки)
	
	Если ОбъектМетаданных.Измерения.Количество() = 0 Тогда
		Возврат;
	КонецЕсли;
	
	Если ОбщегоНазначения.ЭтоРегистрНакопления(ОбъектМетаданных)
		Или ОбщегоНазначения.ЭтоРегистрБухгалтерии(ОбъектМетаданных)
		Или ОбщегоНазначения.ЭтоРегистрРасчета(ОбъектМетаданных)
		Или (ОбщегоНазначения.ЭтоРегистрСведений(ОбъектМетаданных)
			И ОбъектМетаданных.РежимЗаписи = Метаданные.СвойстваОбъектов.РежимЗаписиРегистра.ПодчинениеРегистратору) Тогда
		НайтиНезаполненныеОбязательныеРеквизитыВПодчиненныхРегистрах(ОбъектМетаданных, ПараметрыПроверки);
	Иначе
		НайтиНезаполненныеОбязательныеРеквизитыВНеПодчиненныхРегистрах(ОбъектМетаданных, ПараметрыПроверки);
	КонецЕсли;
	
КонецПроцедуры

Процедура НайтиНезаполненныеОбязательныеРеквизитыВПодчиненныхРегистрах(ОбъектМетаданных, ПараметрыПроверки)
	
	ПолноеИмя = ОбъектМетаданных.ПолноеИмя();
	
	ТекстЗапроса =
	"ВЫБРАТЬ ПЕРВЫЕ 1000
	|	ОбъектМетаданных.НомерСтроки КАК НомерСтроки,
	|	ОбъектМетаданных.Регистратор КАК РегистраторРеквизитСсылка,
	|	ПРЕДСТАВЛЕНИЕССЫЛКИ(ОбъектМетаданных.Регистратор) КАК РегистраторПредставление
	|ИЗ
	|	&ОбъектМетаданных КАК ОбъектМетаданных
	|ГДЕ
	|	ВЫБОР
	|			КОГДА ОбъектМетаданных.Регистратор = &Регистратор
	|				ТОГДА ОбъектМетаданных.НомерСтроки > &НомерСтроки
	|			ИНАЧЕ ОбъектМетаданных.Регистратор > &Регистратор
	|		КОНЕЦ
	|	И &УсловиеОграниченияПоДате
	|
	|УПОРЯДОЧИТЬ ПО
	|	ОбъектМетаданных.Регистратор,
	|	ОбъектМетаданных.НомерСтроки";
	
	Запрос = Новый Запрос;
	Запрос.УстановитьПараметр("НомерСтроки", 0);
	Если Не (ОбщегоНазначения.ЭтоРегистрСведений(ОбъектМетаданных) 
		И ОбъектМетаданных.ПериодичностьРегистраСведений = Метаданные.СвойстваОбъектов.ПериодичностьРегистраСведений.Непериодический) Тогда
		Если ОбщегоНазначения.ЭтоРегистрРасчета(ОбъектМетаданных) Тогда
			ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "&УсловиеОграниченияПоДате", "ОбъектМетаданных.ПериодРегистрации > &ДатаНачалаПроверки");
		Иначе
			ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "&УсловиеОграниченияПоДате", "ОбъектМетаданных.Период > &ДатаНачалаПроверки");
		КонецЕсли;
		Запрос.УстановитьПараметр("ДатаНачалаПроверки", ПараметрыПроверки.ДатаНачалаПроверки);
	Иначе
		ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "&УсловиеОграниченияПоДате", "Истина");
	КонецЕсли;
	Запрос.УстановитьПараметр("Регистратор", "");
	
	ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "&ОбъектМетаданных", ПолноеИмя);
	Запрос.Текст = ТекстЗапроса;
	Результат    = Запрос.Выполнить().Выгрузить();
	
	Пока Истина Цикл
		
		Если Результат.Количество() = 0 Тогда
			Прервать;
		КонецЕсли;
		
		Для Каждого СтрокаРезультата Из Результат Цикл
			
			МенеджерРегистра    = ОбщегоНазначения.МенеджерОбъектаПоПолномуИмени(ПолноеИмя);
			ТекущийНаборЗаписей = МенеджерРегистра.СоздатьНаборЗаписей();
			ТекущийНаборЗаписей.Отбор.Регистратор.Установить(СтрокаРезультата.РегистраторРеквизитСсылка);
			ТекущийНаборЗаписей.Прочитать();
			
			УточнениеПроблемы = "";
			Если Не ТекущийНаборЗаписей.ПроверитьЗаполнение() Тогда
				УточнениеПроблемы = УточнениеПроблемы(ПолучитьСообщенияПользователю(Истина));
			КонецЕсли;
			
			Если Не ЗначениеЗаполнено(УточнениеПроблемы) Тогда
				Продолжить;
			КонецЕсли;
			
			СтруктураНабораЗаписей = Новый Структура;
			СтруктураНабораЗаписей.Вставить("Регистратор", СтрокаРезультата["РегистраторРеквизитСсылка"]);
			
			Проблема = ОписаниеПроблемы(ОбщегоНазначения.ИдентификаторОбъектаМетаданных(ОбъектМетаданных), ПараметрыПроверки);
			Проблема.УточнениеПроблемы        = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(НСтр("ru = 'У записи с полями:
			|%1,
			|обнаружены не заполненные данные обязательные к заполнению: %2'"),
			" • " + НСтр("ru = 'Регистратор:'") + " = """ + СтрокаРезультата.РегистраторПредставление, Символы.ПС + УточнениеПроблемы);
			Проблема.ДополнительнаяИнформация = Новый ХранилищеЗначения(СтруктураНабораЗаписей);
			ЗаписатьПроблему(Проблема, ПараметрыПроверки);
			
		КонецЦикла;
		
		Запрос.УстановитьПараметр("НомерСтроки", СтрокаРезультата.НомерСтроки);
		Запрос.УстановитьПараметр("Регистратор", СтрокаРезультата.РегистраторРеквизитСсылка);
		Результат = Запрос.Выполнить().Выгрузить();
		
	КонецЦикла;
	Запрос = Неопределено;
	
КонецПроцедуры

Процедура НайтиНезаполненныеОбязательныеРеквизитыВНеПодчиненныхРегистрах(ОбъектМетаданных, ПараметрыПроверки)
	
	Измерения = ОбъектМетаданных.Измерения;
	
	ИнформацияОМетаданных = Новый ТаблицаЗначений;
	ИнформацияОМетаданных.Колонки.Добавить("ТипМетаданныхВИминительномПадеже", Новый ОписаниеТипов("Строка", , , , Новый КвалификаторыСтроки(16)));
	ИнформацияОМетаданных.Колонки.Добавить("ТипМетаданныхВТворительномПадеже", Новый ОписаниеТипов("Строка", , , , Новый КвалификаторыСтроки(16)));
	ИнформацияОМетаданных.Колонки.Добавить("ИмяМетаданных",                    Новый ОписаниеТипов("Строка", , , , Новый КвалификаторыСтроки(128)));
	
	ПоляВыборки = "";
	Для Каждого Измерение Из Измерения Цикл
		ИмяИзмерения = Измерение.Имя;
		ПоляВыборки  = ПоляВыборки + ?(ЗначениеЗаполнено(ПоляВыборки), ",", "") + ИмяИзмерения + " Как " + ИмяИзмерения
			+ "ИзмерениеСсылка,ПредставлениеСсылки(" + ИмяИзмерения + ") Как " + ИмяИзмерения + "ИзмерениеПредставление";
		ЗаполнитьЗначенияСвойств(ИнформацияОМетаданных.Добавить(),
			Новый Структура("ТипМетаданныхВИминительномПадеже, ТипМетаданныхВТворительномПадеже, ИмяМетаданных", "Измерение", НСтр("ru = 'измерении'"), ИмяИзмерения));
		КонецЦикла;
	
	Если ОбъектМетаданных.ПериодичностьРегистраСведений <> Метаданные.СвойстваОбъектов.ПериодичностьРегистраСведений.Непериодический Тогда
		НайтиНезаполненныеОбязательныеРеквизитыВНеПодчиненныхПериодическихРегистрахСведений(ОбъектМетаданных, ПоляВыборки, ИнформацияОМетаданных, ПараметрыПроверки);
	Иначе
		НайтиНезаполненныеОбязательныеРеквизитыВНеПодчиненныхНепериодическихРегистрахСведений(ОбъектМетаданных, ПоляВыборки, ИнформацияОМетаданных, ПараметрыПроверки);
	КонецЕсли;
	
КонецПроцедуры

Процедура НайтиНезаполненныеОбязательныеРеквизитыВНеПодчиненныхНепериодическихРегистрахСведений(ОбъектМетаданных, ПоляВыборки, ИнформацияОМетаданных, ПараметрыПроверки)
	
	ПолноеИмя          = ОбъектМетаданных.ПолноеИмя();
	Условие            = "";
	ПоляУпорядочивания = "";
	Измерения          = ОбъектМетаданных.Измерения;
	
	Для Каждого Измерение Из Измерения Цикл
		Условие            = Условие + ?(ЗначениеЗаполнено(Условие), " И ", "") + Измерение.Имя + " >= &" + Измерение.Имя;
		ПоляУпорядочивания = ПоляУпорядочивания + ?(ЗначениеЗаполнено(ПоляУпорядочивания), ", ", "") + Измерение.Имя;
	КонецЦикла;
	
	ТекстЗапроса =
	"ВЫБРАТЬ ПЕРВЫЕ 1000
	|	&ПоляВыборки КАК ПоляВыборки
	|ИЗ
	|	&ОбъектМетаданных КАК ОбъектМетаданных
	|ГДЕ
	|	&Условие";
	
	ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "&Условие",          "ИСТИНА УПОРЯДОЧИТЬ ПО " + ПоляУпорядочивания);
	ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "КАК ПоляВыборки",   "");
	ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "&ОбъектМетаданных", ОбъектМетаданных.ПолноеИмя());
	ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "&ПоляВыборки",      ПоляВыборки);
	
	Запрос    = Новый Запрос(ТекстЗапроса);
	Результат = Запрос.Выполнить().Выгрузить();
	
	УсловиеАбсолюта = "ГДЕ" + Символы.ПС + Символы.Таб + "ИСТИНА";
	Пока Истина Цикл
		
		ЭтоПервыйПроход = СтрНайти(Запрос.Текст, УсловиеАбсолюта) <> 0;
		
		Если Результат.Количество() = 0 Или (Не ЭтоПервыйПроход И Результат.Количество() = 1) Тогда
			Прервать;
		КонецЕсли;
		
		Для Каждого СтрокаРезультата Из Результат Цикл
			
			Если Не ЭтоПервыйПроход И Результат.Индекс(СтрокаРезультата) = 0 Тогда
				Продолжить;
			КонецЕсли;
			
			МенеджерРегистра    = ОбщегоНазначения.МенеджерОбъектаПоПолномуИмени(ПолноеИмя);
			ТекущийНаборЗаписей = МенеджерРегистра.СоздатьНаборЗаписей();
			ОтборТекущегоНабора = ТекущийНаборЗаписей.Отбор;
			
			ПредставлениеОтбораНабораЗаписей = "";
			Для Каждого Измерение Из Измерения Цикл
				
				ИмяИзмерения      = Измерение.Имя;
				ЗначениеИзмерения = СтрокаРезультата[ИмяИзмерения + "ИзмерениеСсылка"];
				Если Не ЗначениеЗаполнено(ЗначениеИзмерения) Тогда
					Продолжить;
				КонецЕсли;
				
				ОтборТекущегоНабора[ИмяИзмерения].Установить(ЗначениеИзмерения);
				
				ПредставлениеОтбораНабораЗаписей = ПредставлениеОтбораНабораЗаписей + ?(ЗначениеЗаполнено(ПредставлениеОтбораНабораЗаписей), Символы.ПС, "")
					+ " • " + ИмяИзмерения + " = """ + СтрокаРезультата[ИмяИзмерения + "ИзмерениеПредставление"] + """";
				
			КонецЦикла;
			ТекущийНаборЗаписей.Прочитать();
			
			УточнениеПроблемы = "";
			Если Не ТекущийНаборЗаписей.ПроверитьЗаполнение() Тогда
				УточнениеПроблемы = УточнениеПроблемы(ПолучитьСообщенияПользователю(Истина));
			КонецЕсли;
			
			Если Не ЗначениеЗаполнено(УточнениеПроблемы) Тогда
				Продолжить;
			КонецЕсли;
			
			СтруктураНабораЗаписей = Новый Структура;
			Для Каждого Измерение Из Измерения Цикл
				ИзмерениеСсылка = СтрокаРезультата[Измерение.Имя + "ИзмерениеСсылка"];
				СтруктураНабораЗаписей.Вставить(Измерение.Имя, ИзмерениеСсылка);
			КонецЦикла;
			
			Проблема = ОписаниеПроблемы(ОбщегоНазначения.ИдентификаторОбъектаМетаданных(ОбъектМетаданных), ПараметрыПроверки);
			Проблема.УточнениеПроблемы        = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(НСтр("ru = 'У записи с полями:
				|%1,
				|обнаружены не заполненные данные обязательные к заполнению: %2'"), ПредставлениеОтбораНабораЗаписей, Символы.ПС + УточнениеПроблемы);
			Проблема.ДополнительнаяИнформация = Новый ХранилищеЗначения(СтруктураНабораЗаписей);
			ЗаписатьПроблему(Проблема, ПараметрыПроверки);
			
		КонецЦикла;
		
		Если ЭтоПервыйПроход Тогда
			Запрос.Текст = СтрЗаменить(Запрос.Текст, УсловиеАбсолюта, "Где " + Условие);
		КонецЕсли;
		
		Для Каждого Измерение Из Измерения Цикл
			Запрос.УстановитьПараметр(Измерение.Имя, СтрокаРезультата[Измерение.Имя + "ИзмерениеСсылка"]);
		КонецЦикла;
		
		Результат = Запрос.Выполнить().Выгрузить();
		
	КонецЦикла;
	Запрос = Неопределено;
	
КонецПроцедуры

Процедура НайтиНезаполненныеОбязательныеРеквизитыВНеподчиненныхПериодическихРегистрахСведений(ОбъектМетаданных, ПоляВыборки, ИнформацияОМетаданных, ПараметрыПроверки)
	
	ПолноеИмя          = ОбъектМетаданных.ПолноеИмя();
	Условие            = "Период >= &Период";
	ПоляУпорядочивания = "Период";
	Измерения          = ОбъектМетаданных.Измерения;
	
	Для Каждого Измерение Из Измерения Цикл
		Условие            = Условие + ?(ЗначениеЗаполнено(Условие), " И ", "") + Измерение.Имя + " >= &" + Измерение.Имя;
		ПоляУпорядочивания = ПоляУпорядочивания + ?(ЗначениеЗаполнено(ПоляУпорядочивания), ", ", "") + Измерение.Имя;
	КонецЦикла;
	
	ТекстЗапроса =
	"ВЫБРАТЬ ПЕРВЫЕ 1000
	|	ОбъектМетаданных.Период КАК Период,
	|	&ПоляВыборки КАК ПоляВыборки
	|ИЗ
	|	&ОбъектМетаданных КАК ОбъектМетаданных
	|ГДЕ
	|	ОбъектМетаданных.Период > &ДатаНачалаПроверки
	|	И &Условие";
	
	ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "&Условие",          "Истина И Истина И Истина Упорядочить По " + ПоляУпорядочивания);
	ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "КАК ПоляВыборки",   "");
	ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "&ОбъектМетаданных", ОбъектМетаданных.ПолноеИмя());
	ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "&ПоляВыборки",      ПоляВыборки);
	
	Запрос = Новый Запрос(ТекстЗапроса);
	Запрос.УстановитьПараметр("ДатаНачалаПроверки", ПараметрыПроверки.ДатаНачалаПроверки);
	Результат = Запрос.Выполнить().Выгрузить();
	
	УсловиеАбсолюта = "Истина И Истина И Истина";
	Пока Истина Цикл
		
		ЭтоПервыйПроход = СтрНайти(Запрос.Текст, УсловиеАбсолюта) <> 0;
		
		Если Результат.Количество() = 0 Или (Не ЭтоПервыйПроход И Результат.Количество() = 1) Тогда
			Прервать;
		КонецЕсли;
		
		Для Каждого СтрокаРезультата Из Результат Цикл
			
			МенеджерРегистра    = ОбщегоНазначения.МенеджерОбъектаПоПолномуИмени(ПолноеИмя);
			ТекущийНаборЗаписей = МенеджерРегистра.СоздатьНаборЗаписей();
			ОтборТекущегоНабора = ТекущийНаборЗаписей.Отбор;
			
			ПредставлениеОтбораНабораЗаписей = " • Период = """ + СтрокаРезультата.Период + """";
			Для Каждого Измерение Из Измерения Цикл
				
				ИмяИзмерения      = Измерение.Имя;
				ЗначениеИзмерения = СтрокаРезультата[ИмяИзмерения + "ИзмерениеСсылка"];
				Если Не ЗначениеЗаполнено(ЗначениеИзмерения) Тогда
					Продолжить;
				КонецЕсли;
				
				ОтборТекущегоНабора[ИмяИзмерения].Установить(ЗначениеИзмерения);
				
				ПредставлениеОтбораНабораЗаписей = ПредставлениеОтбораНабораЗаписей + Символы.ПС
					+ " • " + ИмяИзмерения + " = """ + СтрокаРезультата[ИмяИзмерения + "ИзмерениеПредставление"] + """";
				
			КонецЦикла;
			ТекущийНаборЗаписей.Прочитать();
			
			УточнениеПроблемы = "";
			Если Не ТекущийНаборЗаписей.ПроверитьЗаполнение() Тогда
				УточнениеПроблемы = УточнениеПроблемы(ПолучитьСообщенияПользователю(Истина));
			КонецЕсли;
			
			Если Не ЗначениеЗаполнено(УточнениеПроблемы) Тогда
				Продолжить;
			КонецЕсли;
			
			СтруктураНабораЗаписей = Новый Структура;
			СтруктураНабораЗаписей.Вставить("Период", СтрокаРезультата["Период"]);
			Для Каждого Измерение Из Измерения Цикл
				ИзмерениеСсылка = СтрокаРезультата[Измерение.Имя + "ИзмерениеСсылка"];
				СтруктураНабораЗаписей.Вставить(Измерение.Имя, ИзмерениеСсылка);
			КонецЦикла;
			
			Проблема = ОписаниеПроблемы(ОбщегоНазначения.ИдентификаторОбъектаМетаданных(ОбъектМетаданных), ПараметрыПроверки);
			Проблема.УточнениеПроблемы = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(НСтр("ru = 'У записи с полями:
				|%1,
				|обнаружены не заполненные данные обязательные к заполнению: %2'"), ПредставлениеОтбораНабораЗаписей, Символы.ПС + УточнениеПроблемы);
			Проблема.ДополнительнаяИнформация = Новый ХранилищеЗначения(СтруктураНабораЗаписей);
			ЗаписатьПроблему(Проблема, ПараметрыПроверки);
			
		КонецЦикла;
		
		Если ЭтоПервыйПроход Тогда
			Запрос.Текст = СтрЗаменить(Запрос.Текст, УсловиеАбсолюта, Условие);
		КонецЕсли;
		
		Запрос.УстановитьПараметр("Период", СтрокаРезультата["Период"]);
		Для Каждого Измерение Из Измерения Цикл
			Запрос.УстановитьПараметр(Измерение.Имя, СтрокаРезультата[Измерение.Имя + "ИзмерениеСсылка"]);
		КонецЦикла;
		
		Результат = Запрос.Выполнить().Выгрузить();
		
	КонецЦикла;
	Запрос = Неопределено;
	
КонецПроцедуры

#КонецОбласти

#КонецОбласти

#Область ПроверкаЦиклическихСсылок

Процедура НайтиЦиклическиеСсылки(ОбъектМетаданных, ПараметрыПроверки)
	
	ПолноеИмя      = ОбъектМетаданных.ПолноеИмя();
	Реквизиты      = ОбъектМетаданных.Реквизиты;
	ТабличныеЧасти = ОбъектМетаданных.ТабличныеЧасти;
	
	ТекстЗапроса = "
	|ВЫБРАТЬ ПЕРВЫЕ 1000
	|	ОбъектМетаданных.Ссылка КАК Ссылка,
	|	ОбъектМетаданных.Наименование КАК Наименование
	|ИЗ
	|	&ОбъектМетаданных КАК ОбъектМетаданных
	|ГДЕ
	|	ОбъектМетаданных.Ссылка > &Ссылка
	|
	|УПОРЯДОЧИТЬ ПО
	|	ОбъектМетаданных.Ссылка";
	ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "&ОбъектМетаданных", ПолноеИмя);
	
	Запрос = Новый Запрос(ТекстЗапроса);
	Запрос.УстановитьПараметр("Ссылка", "");
	
	Результат = Запрос.Выполнить().Выгрузить();
	
	МассивИсключений = Новый Массив;
	Пока Истина Цикл
		
		Если Результат.Количество() = 0 Тогда
			Прервать;
		КонецЕсли;
		
		Для Каждого СтрокаРезультата Из Результат Цикл
			
			СсылкаНаОбъект = СтрокаРезультата.Ссылка;
			Если МассивИсключений.Найти(СсылкаНаОбъект) <> Неопределено Тогда
				Продолжить;
			КонецЕсли;
			
			СсылкаНаОбъектНаименование = СтрокаРезультата.Наименование;
			МассивЦиклов               = Новый Массив;
			
			НайденЦикл   = Ложь;
			ЦиклВМассиве = Новый Массив;
			ПроверитьЗацикливаниеУровней(СсылкаНаОбъект, СсылкаНаОбъект.Родитель, НайденЦикл, ЦиклВМассиве);
			Если НайденЦикл Тогда
				
				Путь = "";
				
				Для Каждого ЭлементЦикла Из ЦиклВМассиве Цикл
					Путь = Путь + ?(ЗначениеЗаполнено(Путь), " -> ", "") + ОбщегоНазначения.ЗначениеРеквизитаОбъекта(ЭлементЦикла, "Наименование");
					МассивИсключений.Добавить(ЭлементЦикла);
				КонецЦикла;
				
				Если ЗначениеЗаполнено(Путь) Тогда
					УточнениеПроблемы = СсылкаНаОбъектНаименование + " -> " + Путь + " -> " + СсылкаНаОбъектНаименование;
				Иначе
					УточнениеПроблемы = СсылкаНаОбъектНаименование + " -> " + СсылкаНаОбъектНаименование;
				КонецЕсли;
				
				Проблема = ОписаниеПроблемы(СсылкаНаОбъект, ПараметрыПроверки);
				
				Проблема.УточнениеПроблемы = УточнениеПроблемы;
				Если Реквизиты.Найти("Ответственный") <> Неопределено Тогда
					Проблема.Вставить("Ответственный", ОбщегоНазначения.ЗначениеРеквизитаОбъекта(СсылкаНаОбъект, "Ответственный"));
				КонецЕсли;
				
				ЗаписатьПроблему(Проблема, ПараметрыПроверки);
				
			КонецЕсли;
			
		КонецЦикла;
		
		Запрос.УстановитьПараметр("Ссылка", СтрокаРезультата.Ссылка);
		Результат = Запрос.Выполнить().Выгрузить();
		
	КонецЦикла;
	Запрос = Неопределено;
	
КонецПроцедуры

Процедура ПроверитьЗацикливаниеУровней(СсылкаНаОбъект, ТекущийРодитель, НайденЦикл, ЦиклВМассиве)
	
	Если СсылкаНаОбъект = ТекущийРодитель Тогда
		НайденЦикл = Истина;
	ИначеЕсли ЗначениеЗаполнено(ТекущийРодитель) И ЦиклВМассиве.Найти(ТекущийРодитель) = Неопределено Тогда
		ЦиклВМассиве.Добавить(ТекущийРодитель);
		ПроверитьЗацикливаниеУровней(СсылкаНаОбъект, ТекущийРодитель.Родитель, НайденЦикл, ЦиклВМассиве)
	КонецЕсли;
	
КонецПроцедуры

Функция ЕстьИерархия(СтандартныеРеквизиты)
	
	ЕстьИерархия = Ложь;
	Для Каждого СтандартныйРеквизит Из СтандартныеРеквизиты Цикл
		Если СтандартныйРеквизит.Имя = "Родитель" Тогда
			ЕстьИерархия = Истина;
			Прервать;
		КонецЕсли;
	КонецЦикла;
	
	Возврат ЕстьИерархия;
	
КонецФункции

#КонецОбласти

#Область ПроверкаОтсутствующихПредопределенныхЭлементов

Процедура НайтиОтсутствующиеПредопределенныеЭлементы(ОбъектМетаданных, ПараметрыПроверки)
	
	ПолноеИмя                = ОбъектМетаданных.ПолноеИмя();
	ПредопределенныеЭлементы = ОбъектМетаданных.ПолучитьИменаПредопределенных();
	Для Каждого ПредопределенныйЭлемент Из ПредопределенныеЭлементы Цикл
		
		Если СтрНачинаетсяС(ВРег(ПредопределенныйЭлемент), "УДАЛИТЬ") Тогда
			Продолжить;
		КонецЕсли;
		
		НайденныйЭлемент = ОбщегоНазначенияКлиентСервер.ПредопределенныйЭлемент(ПолноеИмя + "." + ПредопределенныйЭлемент);
		Если НайденныйЭлемент = Неопределено Тогда
			
			Проблема  = ОписаниеПроблемы(ОбщегоНазначения.ИдентификаторОбъектаМетаданных(ОбъектМетаданных), ПараметрыПроверки);
			Проблема.УточнениеПроблемы = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(НСтр("ru = 'Предопределенный элемент ""%1"" отсутствует в информационной базе.'"), ПредопределенныйЭлемент);
			ЗаписатьПроблему(Проблема, ПараметрыПроверки);
		
		КонецЕсли;
		
	КонецЦикла;
	
КонецПроцедуры

#КонецОбласти

#Область ПроверкаДублированияПредопределенныхЭлементов

Процедура НайтиДублиПредопределенныхЭлементов(ВидМетаданных, ПараметрыПроверки)
	
	Пакеты        = "";
	ШаблонПакетов =
	"ВЫБРАТЬ
	|	""&Таблица"" КАК ПолноеИмя,
	|	&ПрочиеПоля
	|ИЗ
	|	&Таблица КАК Таблица
	|ГДЕ Таблица.Предопределенный
	|
	|СГРУППИРОВАТЬ ПО
	|	Таблица.ИмяПредопределенныхДанных
	|
	|ИМЕЮЩИЕ
	|	КОЛИЧЕСТВО(РАЗЛИЧНЫЕ Таблица.Ссылка) > 1";
	
	Выборки       = "";
	ШаблонВыборки =
	"ВЫБРАТЬ
	|	&ПоляВременнойТаблицы,
	|	ПредставлениеСсылки(Таблица.Ссылка) КАК СсылкаНаДублирующийсяЭлемент
	|ИЗ
	|	&Таблица КАК Таблица
	|		ВНУТРЕННЕЕ СОЕДИНЕНИЕ (Выбрать ""&ВременнаяТаблица"") КАК ВременнаяТаблица
	|		ПО &УсловияСоединения";
	
	Для Каждого ОбъектМетаданных Из ВидМетаданных Цикл
		
		Если ОбъектМетаданных.ОбновлениеПредопределенныхДанных = Метаданные.СвойстваОбъектов.ОбновлениеПредопределенныхДанных.НеОбновлятьАвтоматически Тогда
			Продолжить;
		КонецЕсли;
		
		ПолноеИмя           = ОбъектМетаданных.ПолноеИмя();
		ИмяВременнойТаблицы = "ВТ_" + СтрЗаменить(ПолноеИмя, ".", "");
		
		ЭлементШаблонаПакетов = СтрЗаменить(ШаблонПакетов, "&ПрочиеПоля",
			"Таблица.ИмяПредопределенныхДанных КАК ИмяПредопределенныхДанных Поместить " + ИмяВременнойТаблицы);
		ЭлементШаблонаПакетов = СтрЗаменить(ЭлементШаблонаПакетов, "&Таблица", ПолноеИмя);
		
		Пакеты = Пакеты + ?(ЗначениеЗаполнено(Пакеты), ";", "") + ЭлементШаблонаПакетов;
		
		ЭлементШаблонаВыборки = СтрЗаменить(ШаблонВыборки, "&ПоляВременнойТаблицы",
			" ВременнаяТаблица.ПолноеИмя  КАК ПолноеИмя, ВременнаяТаблица.ИмяПредопределенныхДанных КАК ИмяПредопределенныхДанных");
		ЭлементШаблонаВыборки = СтрЗаменить(ЭлементШаблонаВыборки, "&Таблица", ПолноеИмя);
		ЭлементШаблонаВыборки = СтрЗаменить(ЭлементШаблонаВыборки, "(Выбрать ""&ВременнаяТаблица"")", ИмяВременнойТаблицы);
		ЭлементШаблонаВыборки = СтрЗаменить(ЭлементШаблонаВыборки, "&УсловияСоединения",
			"Таблица.ИмяПредопределенныхДанных = ВременнаяТаблица.ИмяПредопределенныхДанных");
		
		Выборки = Выборки + ?(ЗначениеЗаполнено(Выборки), " ОБЪЕДИНИТЬ ВСЕ ", "") + ЭлементШаблонаВыборки;
		
	КонецЦикла;
	
	Запрос = Новый Запрос(Пакеты + ";" + Выборки + " ИТОГИ ПО ПолноеИмя, ИмяПредопределенныхДанных");
	Запрос.МенеджерВременныхТаблиц = Новый МенеджерВременныхТаблиц;
	
	ОбщийРезультат = Запрос.Выполнить().Выбрать(ОбходРезультатаЗапроса.ПоГруппировкам);
	
	Пока ОбщийРезультат.Следующий() Цикл
		
		УточнениеПроблемы = "";
		ПолноеИмя         = ОбщийРезультат.ПолноеИмя;
		РезультатПоИмени  = ОбщийРезультат.Выбрать(ОбходРезультатаЗапроса.ПоГруппировкам);
		
		Пока РезультатПоИмени.Следующий() Цикл
			
			Если СтрНачинаетсяС(ВРег(РезультатПоИмени.ИмяПредопределенныхДанных), "УДАЛИТЬ") Тогда
				Продолжить;
			КонецЕсли;
			
			УточнениеПроблемы = УточнениеПроблемы + ?(ЗначениеЗаполнено(УточнениеПроблемы), Символы.ПС, "")
				+ НСтр("ru = 'Имя предопределенного элемента:'") + " """ + РезультатПоИмени.ИмяПредопределенныхДанных + """"
				+ Символы.ПС + НСтр("ru = 'Ссылки на предопределенный элемент:'");
				
			ДетальныеЗаписи = РезультатПоИмени.Выбрать();
			Пока ДетальныеЗаписи.Следующий() Цикл
				УточнениеПроблемы = УточнениеПроблемы + ?(ЗначениеЗаполнено(УточнениеПроблемы), Символы.ПС, "")
					+ " • """ + ДетальныеЗаписи.СсылкаНаДублирующийсяЭлемент + """";
			КонецЦикла;
			
		КонецЦикла;
		
		Если Не ЗначениеЗаполнено(УточнениеПроблемы) Тогда
			Продолжить;
		КонецЕсли;
		
		Проблема = ОписаниеПроблемы(ОбщегоНазначения.ИдентификаторОбъектаМетаданных(ПолноеИмя), ПараметрыПроверки);
		Проблема.УточнениеПроблемы = УточнениеПроблемы;
		ЗаписатьПроблему(Проблема, ПараметрыПроверки);
		
	КонецЦикла;
	
	Запрос.МенеджерВременныхТаблиц.Закрыть();
	Запрос = Неопределено;
	
КонецПроцедуры

#КонецОбласти

#Область ИсправлениеПроблемЦиклическиеСсылки

// Исправляет проблему циклических ссылок по принципу у кого больше терминальных элементов
// в подчинении, тот и остается родителем.
//
// Параметры:
//   Проверка - СправочникСсылка.ПравилаПроверкиУчета - Проверка, найденные проблемы которой
//              исправляются данным методом.
//
Процедура ИсправитьПроблемуЦиклическихСсылок(Проверка)
	
	ТаблицаПотомства = Новый ТаблицаЗначений;
	ТаблицаПотомства.Колонки.Добавить("ЭлементЦикла");
	ТаблицаПотомства.Колонки.Добавить("КоличествоДетей", Новый ОписаниеТипов("Число"));
	
	Запрос = Новый Запрос(
	"ВЫБРАТЬ
	|	РезультатыПроверкиУчета.ПроблемныйОбъект КАК ПроблемныйОбъект
	|ИЗ
	|	РегистрСведений.РезультатыПроверкиУчета КАК РезультатыПроверкиУчета
	|ГДЕ
	|	НЕ РезультатыПроверкиУчета.ИгнорироватьПроблему
	|	И РезультатыПроверкиУчета.ПравилоПроверки = &ПравилоПроверки");
	
	Запрос.УстановитьПараметр("ПравилоПроверки", Проверка);
	Результат = Запрос.Выполнить().Выбрать();
	
	Пока Результат.Следующий() Цикл
		
		ПроблемныйОбъект = Результат.ПроблемныйОбъект;
		Родитель         = ПроблемныйОбъект.Родитель;
		
		НайденЦикл   = Ложь;
		ЦиклВМассиве = Новый Массив;
		ПроверитьЗацикливаниеУровней(ПроблемныйОбъект, Родитель, НайденЦикл, ЦиклВМассиве);
		Если НайденЦикл Тогда
			
			КоличествоДетейПервого = 0;
			КоличествоДетейВторого = 0;
			
			ПоследнийОбъектЦикла = ЦиклВМассиве.Получить(ЦиклВМассиве.Количество() - 1);
			
			ПолучитьКоличествоДетей(ПроблемныйОбъект, Родитель, КоличествоДетейПервого);
			ПолучитьКоличествоДетей(ПоследнийОбъектЦикла, Родитель, КоличествоДетейВторого);
			
			Если КоличествоДетейПервого > КоличествоДетейВторого Тогда
				ОбъектСсылки = ПроблемныйОбъект.ПолучитьОбъект();
			ИначеЕсли КоличествоДетейПервого < КоличествоДетейВторого Тогда
				ОбъектСсылки = ПоследнийОбъектЦикла.ПолучитьОбъект();
			Иначе
				
				ГСЧ = Новый ГенераторСлучайныхЧисел;
				
				Массив = Новый Массив;
				Массив.Добавить(ПроблемныйОбъект);
				Массив.Добавить(ПоследнийОбъектЦикла);
				
				ОбъектСсылки = Массив.Получить(ГСЧ.СлучайноеЧисло(0, 1)).ПолучитьОбъект();
				
			КонецЕсли;
			
			ОбъектСсылки.Родитель              = ОбщегоНазначения.МенеджерОбъектаПоПолномуИмени(ПроблемныйОбъект.Метаданные().ПолноеИмя()).ПустаяСсылка();
			ОбъектСсылки.ОбменДанными.Загрузка = Истина;
			ОбъектСсылки.Записать();
			
		КонецЕсли;
		
	КонецЦикла;
	
КонецПроцедуры

Процедура ПолучитьКоличествоДетей(СсылкаНаОбъект, ИсключениеВыборки, КоличествоДетей)
	
	ТекстЗапроса =
	"ВЫБРАТЬ
	|	ОбъектМетаданных.Ссылка КАК Ссылка
	|ИЗ
	|	&ОбъектМетаданных КАК ОбъектМетаданных
	|ГДЕ
	|	ОбъектМетаданных.Родитель = &Родитель
	|	И ОбъектМетаданных.Ссылка <> &ИсключениеВыборки";
	
	ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "&ОбъектМетаданных", СсылкаНаОбъект.Метаданные().ПолноеИмя());
	
	Запрос = Новый Запрос(ТекстЗапроса);
	Запрос.УстановитьПараметр("Родитель",          СсылкаНаОбъект);
	Запрос.УстановитьПараметр("ИсключениеВыборки", ИсключениеВыборки);
	Результат = Запрос.Выполнить();
	
	Если Не Результат.Пустой() Тогда
		Выгрузка        = Результат.Выгрузить();
		КоличествоДетей = КоличествоДетей + Выгрузка.Количество();
		Для Каждого ЭлементПотомства Из Выгрузка Цикл
			ПолучитьКоличествоДетей(ЭлементПотомства.Ссылка, ИсключениеВыборки, КоличествоДетей);
		КонецЦикла;
	КонецЕсли;
	
КонецПроцедуры

#КонецОбласти

#Область ДополнительнаяФункциональностьДляРаботыВСКД

Функция ОформитьПредставлениеПроблемногоОбъекта(ПроблемныйОбъект, ПроблемныйОбъектПредставление, ДополнительнаяИнформация) Экспорт
	
	ОформленноеПредставлениеОбъекта = ПроблемныйОбъектПредставление + " (" + ПроблемныйОбъект.Метаданные().Представление() + ")";
	
	Если ТипЗнч(ПроблемныйОбъект) <> Тип("СправочникСсылка.ИдентификаторыОбъектовМетаданных") Тогда
		Возврат ОформленноеПредставлениеОбъекта;
	Иначе
		ПолноеИмя = ПроблемныйОбъект.ПолноеИмя;
		Если Не ОбщегоНазначения.ЭтоРегистр(Метаданные.НайтиПоПолномуИмени(ПолноеИмя)) Тогда
			Возврат ПроблемныйОбъектПредставление;
		Иначе
			
			СтруктураНабора  = ДополнительнаяИнформация.Получить();
			
			Если ТипЗнч(СтруктураНабора) <> Тип("Структура") Тогда
				Возврат ОформленноеПредставлениеОбъекта;
			КонецЕсли;
			
			СтрокаРазмещения = Строка(ПроблемныйОбъект) + "<Размещение структуры набора записей для последующей расшифровки>" + Символы.ПС + ПолноеИмя;
			Для Каждого ЭлементНабора Из СтруктураНабора Цикл
				
				ЗначениеОтбора    = ЭлементНабора.Значение;
				ТипЗначенияОтбора = ТипЗнч(ЗначениеОтбора);
				ИнформацияОТипе   = "";
				
				Если ТипЗначенияОтбора = Тип("Число") Тогда
					ИнформацияОТипе = "Число";
				ИначеЕсли ТипЗначенияОтбора = Тип("Строка") Тогда
					ИнформацияОТипе = "Строка";
				ИначеЕсли ТипЗначенияОтбора = Тип("Булево") Тогда
					ИнформацияОТипе = "Булево";
				ИначеЕсли ТипЗначенияОтбора = Тип("Дата") Тогда
					ИнформацияОТипе = "Дата";
				ИначеЕсли ОбщегоНазначения.ЭтоСсылка(ТипЗначенияОтбора) Тогда
					ИнформацияОТипе = ЗначениеОтбора.Метаданные().ПолноеИмя();
				КонецЕсли;
				
				СтрокаРазмещения = СтрокаРазмещения + Символы.ПС + Строка(ЭлементНабора.Ключ) + "~~~" + ИнформацияОТипе + "~~~" + Строка(XMLСтрока(ЗначениеОтбора));
				
			КонецЦикла;
			
			Возврат СтрокаРазмещения;
			
		КонецЕсли;
	КонецЕсли;
	
КонецФункции

#КонецОбласти

#Область ПроцедурыИФункцииОбщегоНазначенияСлужебная

Функция УточнениеПроблемы(МассивСообщений)
	
	УточнениеПроблемы = "";
	Для Каждого ПользовательскоеСообщение Из МассивСообщений Цикл
		УточнениеПроблемы = УточнениеПроблемы + ?(ЗначениеЗаполнено(УточнениеПроблемы), Символы.ПС, "") + ПользовательскоеСообщение.Текст;
	КонецЦикла;
	
	Возврат УточнениеПроблемы;
	
КонецФункции

Функция ПроверкаОтложена(ИдентификаторРегламентногоЗадания)
	
	ПроверкаОтложена = Ложь;
	Если ЗначениеЗаполнено(ИдентификаторРегламентногоЗадания) Тогда
		Задание = ФоновыеЗадания.НайтиПоУникальномуИдентификатору(Новый УникальныйИдентификатор(ИдентификаторРегламентногоЗадания));
		Если Задание <> Неопределено И Задание.Состояние = СостояниеФоновогоЗадания.Активно Тогда
			ПроверкаОтложена = Истина;
		КонецЕсли;
	КонецЕсли;
	
	Возврат ПроверкаОтложена;
	
КонецФункции

// Подготавливает параметры проверки к дальнейшей записи в регистр сведений "РезультатыПроверкиУчета".
// А именно: Дополняет параметры выполняемой проверки видом проверки, ссылкой на проверку и важностью проблемы
// И затирает предыдущую информацию в упомянутом регистре.
// Параметры:
//   ПроблемныйОбъект  - ЛюбаяСсылка - Ссылка на объект "Источник" проблем.
//   ПараметрыПроверки - Структура - Параметры проверки которую необходимо выполнить:
//       * Идентификатор                     - Строка - Строковый идентификатор проверки.
//       * Представление                     - Строка - Пользовательское представление проверки.
//       * ИдентификаторРегламентногоЗадания - Строка - Строковый идентификатор регламентного задания,
//                                             соответствующего проверке.
//       * ДатаНачалаПроверки                - Дата - Пороговая дата, обозначающая границу проверяемых
//                                             объектов (только для объектов с датой). Объекты, дата которых
//                                             меньше указанной, не следует проверять. По умолчанию не 
//                                             заполнено (т.е. проверять все).
//       * ЛимитПроблем                      - Число - Количество проверяемых объектов.
//                                             По умолчанию 1000. Если указано 0, то следует проверить все объекты.
//       * ИтерацияПроверки                  - Число - Очередная итерация проверки. Используется совместно с параметром
//                                             ЛимитПроблем для определения предельного количества итераций.
//       * Проверка                          - СправочникСсылка.ПравилаПроверкиУчета - Ссылка на
//                                             выполненную проверку.
//       * ВидПроверки                       - СправочникСсылка.ВидыПроверок - Ссылка на вид проверки, к
//                                             которому относится выполненная проверка.
//       * ВажностьПроблемы                  - ПеречислениеСсылка.ВажностьПроблемыУчета - Важность проблемы учета
//                                             "Информация", "Предупреждение", "Ошибка" и "ПолезныйСовет".
//
Процедура ПодготовитьДанныеПроверки(Проверка, ПараметрыПроверки)
	
	Параметры = Новый Структура;
	ПараметрыСинхронизации = Новый Структура;
	
	Параметры.Вставить("ПараметрыСинхронизации", ПараметрыСинхронизации);
	Параметры.Вставить("Идентификатор",          "СистемныеПроверки");
	Параметры.Вставить("Представление",          НСтр("ru='Системные проверки'"));
	
	ПодготовленныеПараметры = ПараметрыСинхронизацииВидаПроверок(Параметры);
	
	ВидПроверки = СинхронизацияВидаПроверки(ПодготовленныеПараметры);
	ПараметрыПроверки.Вставить("Проверка",            Проверка);
	ПараметрыПроверки.Вставить("ВидПроверки",         ВидПроверки);
	ПараметрыПроверки.Вставить("ВажностьПроблемы",    ОбщегоНазначения.ЗначениеРеквизитаОбъекта(Проверка, "ВажностьПроблемы"));
	ПараметрыПроверки.Вставить("ГлобальныеНастройки", ГлобальныеНастройки());
	ПараметрыПроверки.Вставить("ИтерацияПроверки",    1);
	
	Набор = РегистрыСведений.РезультатыПроверкиУчета.СоздатьНаборЗаписей();
	Набор.Отбор.ВидПроверки.Установить(ВидПроверки);
	Набор.Отбор.ПравилоПроверки.Установить(Проверка);
	Набор.Записать();
	
КонецПроцедуры

// Выполняет проверку превышения количества итераций проверки допустимого лимита.
//
// Параметры:
//   ПараметрыПроверки - Структура - Сформированная алгоритмом проверки структура проблемы.
//      * Идентификатор                     - Строка - Строковый идентификатор проверки.
//      * Представление                     - Строка - Пользовательское представление проверки.
//      * ИдентификаторРегламентногоЗадания - Строка - Строковый идентификатор регламентного задания,
//                                            соответствующего проверке.
//      * ДатаНачалаПроверки                - Дата - Пороговая дата, обозначающая границу проверяемых
//                                            объектов (только для объектов с датой). Объекты, дата которых
//                                            меньше указанной, не следует проверять. По умолчанию не 
//                                            заполнено (т.е. проверять все).
//      * ЛимитПроблем                      - Число - Количество проверяемых объектов.
//                                            По умолчанию 1000. Если указано 0, то следует проверить все объекты.
//      * ИтерацияПроверки                  - Число - Очередная итерация проверки. Используется совместно с параметром
//                                            ЛимитПроблем для определения предельного количества итераций.
//      * Проверка                          - СправочникСсылка.ПравилаПроверкиУчета - Ссылка на
//                                            выполненную проверку.
//      * ВидПроверки                       - СправочникСсылка.ВидыПроверок - Ссылка на вид проверки, к
//                                            которому относится выполненная проверка.
//      * ВажностьПроблемы                  - ПеречислениеСсылка.ВажностьПроблемыУчета - Важность проблемы учета
//                                            "Информация", "Предупреждение", "Ошибка" и "ПолезныйСовет".
//
// Возвращаемое значение:
//   Булево - Признак того достигнута ли последняя итерация.
//
Функция ЭтоПоследняяИтерацияПроверки(ПараметрыПроверки)
	
	ЭтоПоследняяИтерация = Ложь;
	
	Если ПараметрыПроверки.ЛимитПроблем <> 0 Тогда
		Если ПараметрыПроверки.ИтерацияПроверки > ПараметрыПроверки.ЛимитПроблем Тогда
			ЭтоПоследняяИтерация = Истина;
		Иначе
			ПараметрыПроверки.Вставить("ИтерацияПроверки", ПараметрыПроверки.ИтерацияПроверки + 1);
		КонецЕсли;
	КонецЕсли;
	
	Возврат ЭтоПоследняяИтерация;
	
КонецФункции

// Возвращает строковое представление вида объектов метаданных по типу объекта.
// Ограничение: не обрабатываются точки маршрутов бизнес-процессов.
//
// Параметры:
//  СсылкаНаОбъект - ЛюбаяСсылка - Ссылка на проблемный объект.
//
// Возвращаемое значение:
//  Строка - представление вида объектов метаданных. Например: "Справочник", "Документ".
//
Функция ПредставлениеОбъектаПоТипу(СсылкаНаОбъект)
	
	ТипОбъекта = ТипЗнч(СсылкаНаОбъект);
	
	Если Справочники.ТипВсеСсылки().СодержитТип(ТипОбъекта) Тогда
		
		Возврат НСтр("ru = 'элементом справочника'");
	
	ИначеЕсли Документы.ТипВсеСсылки().СодержитТип(ТипОбъекта) Тогда
		Возврат НСтр("ru = 'документом'");
	
	ИначеЕсли БизнесПроцессы.ТипВсеСсылки().СодержитТип(ТипОбъекта) Тогда
		Возврат НСтр("ru = 'бизнес процессом'");
	
	ИначеЕсли ПланыВидовХарактеристик.ТипВсеСсылки().СодержитТип(ТипОбъекта) Тогда
		Возврат НСтр("ru = 'планом видов характеристик'");
	
	ИначеЕсли ПланыСчетов.ТипВсеСсылки().СодержитТип(ТипОбъекта) Тогда
		Возврат НСтр("ru = 'планом счетов'");
	
	ИначеЕсли ПланыВидовРасчета.ТипВсеСсылки().СодержитТип(ТипОбъекта) Тогда
		Возврат НСтр("ru = 'планом видов расчета'");
	
	ИначеЕсли Задачи.ТипВсеСсылки().СодержитТип(ТипОбъекта) Тогда
		Возврат НСтр("ru = 'задачей'");
	
	ИначеЕсли ПланыОбмена.ТипВсеСсылки().СодержитТип(ТипОбъекта) Тогда
		Возврат НСтр("ru = 'планом обмена'");
	
	ИначеЕсли Перечисления.ТипВсеСсылки().СодержитТип(ТипОбъекта) Тогда
		Возврат НСтр("ru = 'перечислением'");
	
	Иначе
		ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(НСтр("ru='Неверный тип значения параметра (%1)'"), Строка(ТипОбъекта));
	
	КонецЕсли;
	
КонецФункции

#КонецОбласти

#КонецОбласти
